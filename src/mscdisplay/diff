Only in .: evvexpr.com
Only in .: evvexpr.x
Only in /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay: fixsec.cl
Only in /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay: flatcompress.cl
Only in /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay: imdwcsver.x
Only in /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay: maskcolor.x
Only in .: mfree.x
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/mimpars.par ./mimpars.par
10a11
> zerosub,b,h,yes,,,"do zero subtraction?"
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/mkpkg ./mkpkg
3d2
< $call	lmscdisp
13a13
> 	$update	libpkg.a
18c18
< 	$set    LIBS1 = "-lccdred -lmscred -lds -lxtools -lcurfit -lgsurfit"
---
> 	$set    LIBS1 = "-lnfe -lds -lxtools -lcurfit -lgsurfit"
21c21
< 	$checkout x_mscdisplay.o mscbin$
---
> 	$call	starfocus@src
23,32c23,24
< 	$omake maskcolor.x
< 	$iffile (pkg$images/tv/display/imdwcsver.x)
< 	    $link x_mscdisplay.o maskcolor.o -lsf -lmscdisp\
< 		$(LIBS1) $(LIBS2) -o xx_mscdisplay.e
< 	$else
< 	    $omake imdwcsver.x
< 	    $link x_mscdisplay.o imdwcsver.o -lsf -lmscdisp\
< 		$(LIBS1) $(LIBS2) -o xx_mscdisplay.e
< 	$endif
< 	$checkin x_mscdisplay.o mscbin$
---
> 	$link x_mscdisplay.o src/starfocus/libpkg.a libpkg.a\
> 	    $(LIBS1) $(LIBS2) -o xx_mscdisplay.e
36,37c28,29
< 	$set    LIBS1 = "-lccdred -lmscred -lslalib -lds -lxtools -lcurfit"
< 	$set	LIBS2 = "-lgsurfit -lnlfit -liminterp -lncar -lgks -lllsq"
---
> 	$set    LIBS1 = "-lnfe -lds -lxtools -lcurfit -lgsurfit"
> 	$set	LIBS2 = "-lnlfit -liminterp -lncar -lgks -lllsq"
39c31
< 	$checkout x_mscexam.o mscbin$
---
> 	$call	mscexam@src
41,49c33,34
< 	$iffile (pkg$images/tv/display/imdwcsver.x)
< 	    $link x_mscexam.o -limexam -lmscdisp\
< 		$(LIBS1) $(LIBS2) -o xx_mscexam.e
< 	$else
< 	    $omake imdwcsver.x
< 	    $link x_mscexam.o imdwcsver.o -limexam -lmscdisp\
< 		$(LIBS1) $(LIBS2) -o xx_mscexam.e
< 	$endif
< 	$checkin x_mscexam.o mscbin$
---
> 	$link x_mscexam.o src/imexam/libpkg.a libpkg.a ../libpkg.a\
> 	    -lslalib $(LIBS1) $(LIBS2) -o xx_mscexam.e
53,62c38,39
< 	$move	xx_mscdisplay.e mscbin$x_mscdisplay.e
< 	$move	xx_mscexam.e mscbin$x_mscexam.e
< 	;
< 
< lmscdisp:
< 	$call	lmscdisp@src
< 	;
< 
< limexam:
< 	$call	limexam@src
---
> 	$move	xx_mscdisplay.e nfebin$x_mscdisplay.e
> 	$move	xx_mscexam.e nfebin$x_mscexam.e
65,66c42,43
< lsf:
< 	$call	lsf@src
---
> libpkg.a:
> 	@src
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/mscdisplay.par ./mscdisplay.par
3a4
> zero,f,h,"",,,root name for zero subtraction
16d16
< repeat,b,h,no,,,repeat previous display parameters
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/mscexamine.par ./mscexamine.par
2a3
> zero,f,h,"",,,root name for sky subtraction
Only in /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay: mscotfflat.cl
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/mscrtdisplay.par ./mscrtdisplay.par
3a4
> zero,f,h,"",,,root name for zero subtraction
Only in .: sigm2.x
Only in ./src: ace.h
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/imexam/mkpkg ./src/imexam/mkpkg
3,5c3,6
< update:
< 	$call	limexam
< 	;
---
> $checkout libpkg.a ../..
> $update   libpkg.a
> $checkin  libpkg.a ../..
> $exit
7,10c8,9
< limexam:
< 	$checkout libimexam.a mscbin$
< 	$update   libimexam.a
< 	$checkin  libimexam.a mscbin$
---
> update:
> 	$update	libpkg.a
13c12
< libimexam.a:
---
> libpkg.a:
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/imexam/mscexam.h ./src/imexam/mscexam.h
12,15c12,15
< define	imtopen		mitopen
< define	imtrgetim	mitrgetim
< define	imtlen		mitlen
< define	imtclose	mitclose
---
> #define	imtopen		mitopen
> #define	imtrgetim	mitrgetim
> #define	imtlen		mitlen
> #define	imtclose	mitclose
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/imexam/mscexamine.par ./src/imexam/mscexamine.par
2a3
> zero,f,h,"",,,root name for sky subtraction
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/imexam/t_imexam.x ./src/imexam/t_imexam.x
26a27,28
> int	imtgetim()
> 
36c38,39
<         call clgstr    ("instrument",  Memc[instrument],  SZ_FNAME)
---
>         #call clgstr    ("instrument",  Memc[instrument],  SZ_FNAME)
> 	Memc[instrument] = EOS
Only in ./src: maskcolor.x
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/mkpkg ./src/mkpkg
3,7c3,6
< lmscdisp:
< 	$checkout libmscdisp.a mscbin$
< 	$update   libmscdisp.a
< 	$checkin  libmscdisp.a mscbin$
< 	;
---
> $checkout libpkg.a ..
> $update   libpkg.a
> $checkin  libpkg.a ..
> $exit
9,10c8,9
< limexam:
< 	$call	limexam@imexam
---
> starfocus:
> 	$call update@starfocus
13,14c12,13
< lsf:
< 	$call	lsf@starfocus
---
> mscexam:
> 	$call update@imexam
17c16
< libmscdisp.a:
---
> libpkg.a:
39a39
> 	maskcolor.x	ace.h <ctotok.h> <evvexpr.h>
53c53
< 	sigm2.x		<error.h> <imhdr.h> mosgeom.h <pmset.h> xtfixpix.h
---
> 	sigm2.x		<error.h> <imhdr.h> mosgeom.h <pmset.h> <xtfixpix.h>
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/mosgeom.h ./src/mosgeom.h
5a6
> define	LEN_ZERONAME	39		# Length of zero name
7c8
< define	LEN_MOSGEOM 	59		# Length of mosgeom structure.
---
> define	LEN_MOSGEOM 	81		# Length of mosgeom structure.
48,57c49,61
< define	DOFLAT		Memi[$1+28]	# Do flat field division?
< define	FLATNAME	Memc[P2C($1+29)] # Flat field name
< define	DFIM		Memi[$1+49]	# Display flat IMIO pointer
< define	CCDMEAN		Memr[$1+50]	# CCDMEAN value
< define	BIAS		Memr[$1+51]	# Zero offset (bias level) of readout.
< define	OVRSCN		Memi[$1+52]	# Pointer to overscan vector.
< define	GAIN		Memr[$1+53]	# Gain of readout.
< define	DARK		Memr[$1+54]	# Dark rate of readout.
< define	Z1		Memr[$1+55]	# Z1 value for display.
< define	Z2		Memr[$1+56]	# Z2 value for display.
---
> define	DOZERO		Memi[$1+28]	# Do zero subtraction?
> define	DOFLAT		Memi[$1+29]	# Do flat field division?
> define	ZERONAME	Memc[P2C($1+30)] # Zero name
> define	FLATNAME	Memc[P2C($1+50)] # Flat field name
> define	DZIM		Memi[$1+70]	# Display zero IMIO pointer
> define	DFIM		Memi[$1+71]	# Display flat IMIO pointer
> define	CCDMEAN		Memr[$1+72]	# CCDMEAN value
> define	BIAS		Memr[$1+73]	# Zero offset (bias level) of readout.
> define	OVRSCN		Memi[$1+74]	# Pointer to overscan vector.
> define	GAIN		Memr[$1+75]	# Gain of readout.
> define	DARK		Memr[$1+76]	# Dark rate of readout.
> define	Z1		Memr[$1+77]	# Z1 value for display.
> define	Z2		Memr[$1+78]	# Z2 value for display.
60,61c64,65
< define	CKNODATA	Memi[$1+57]	# Check for no data?
< define	NODATA		Memi[$1+58]	# No data found?
---
> define	CKNODATA	Memi[$1+79]	# Check for no data?
> define	NODATA		Memi[$1+80]	# No data found?
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/mosmap.x ./src/mosmap.x
19,20c19,20
< int	mef, proc, dobias, doflat, ninput, err, imext
< pointer	sp, im, mg, template, imname, caldir, filter, inlist
---
> int	rootlen, mef, proc, dobias, dozero, doflat, ninput, err, imext
> pointer	sp, im, mg, template, imname, zname, caldir, filter, inlist
23,24c23,25
< pointer	immap(), mg_open(), mg_compgeom()
< int	mscextensions(), imtopen, imtlen(), imtgetim(), errget(), btoi()
---
> pointer	immap(), mg_open(), mg_compgeom(), imtopenp()
> int	xt_extns(), imtopen, imtlen(), imtgetim()
> int	errget(), btoi(), strlen()
34,35c35,37
< 	call salloc (caldir,    SZ_LINE, TY_CHAR)
< 	call salloc (filter,    SZ_LINE, TY_CHAR)
---
> 	call salloc (zname,    SZ_LINE, TY_CHAR)
> 	call salloc (caldir,   SZ_LINE, TY_CHAR)
> 	call salloc (filter,   SZ_LINE, TY_CHAR)
45a48
> 	rootlen = strlen (image)
47a51
> 
57,58c61,62
< 	    inlist = mscextensions (image, "0-", Memc[template], "",
< 		NO, YES, NO, "", NO, imext)
---
> 	    inlist = xt_extns (image, "IMAGE", "0-", Memc[template], "",
> 		NO, YES, NO, NO, "", NO, imext)
92a97
> 		dozero = btoi (clgetb ("mimpars.zerosub"))
94c99,107
< 		if (dobias == NO && doflat == NO)
---
> 		if (dozero == YES) {
> 		    im = imtopenp ("zero")
> 		    if (imtlen (im) > 1)
> 			call error (1, "Only one zero may be specified")
> 		    if (imtgetim (im, Memc[zname], SZ_LINE) == EOF)
> 		        dozero = NO
> 		    call imtclose (im)
> 		}
> 		if (dobias == NO && dozero == NO && doflat == NO)
108,110c121,123
< 		iferr (mg = mg_open (Memc[imname], acmode, hdr_arg, mef,
< 		    proc, dobias, doflat, Memc[caldir], Memc[filter],
< 		    ninput, im)) {
---
> 		iferr (mg = mg_open (Memc[imname], rootlen, acmode, hdr_arg,
> 		    mef, proc, dobias, dozero, doflat, Memc[zname],
> 		    Memc[caldir], Memc[filter], ninput, im)) {
220,221c233,234
< pointer procedure mg_open (imname, acmode, hdr_arg, mef, proc, dobias,
< 	doflat, caldir, filter, nim,  im)
---
> pointer procedure mg_open (imname, rootlen, acmode, hdr_arg, mef, proc, dobias,
> 	dozero, doflat, zero, caldir, filter, nim,  im)
223a237
> int	rootlen		#I Length of root part of image name
228a243
> int	dozero		#I Do zero subtraction?
229a245
> char	zero[ARB]	#I Zero image
238c254
< pointer	sp, section, filt, str, key, cdir, dfim
---
> pointer	sp, section, tsection, filt, str, key, cdir, dcim
243,244c259,260
< bool	ccdflag(), streq()
< int	strdic(), strlen(), open(), fscan(), nscan()
---
> bool	hdmflag(), streq()
> int	strdic(), strlen(), open(), fscan(), nscan(), stridxs()
253a270
> 	call salloc (tsection, SZ_LINE, TY_CHAR)
444c461
< 		call sprintf (Memc[section], SZ_LINE, "%s[*,-*]")
---
> 		call sprintf (Memc[tsection], SZ_LINE, "[*,-*]")
446c463
< 		call sprintf (Memc[section], SZ_LINE, "%s[-*,*]")
---
> 		call sprintf (Memc[tsection], SZ_LINE, "[-*,*]")
448,449c465,468
< 		call sprintf (Memc[section], SZ_LINE, "%s[-*,-*]")
< 	    call pargstr (imname)
---
> 		call sprintf (Memc[tsection], SZ_LINE, "[-*,-*]")
> 	    call sprintf (Memc[section], SZ_LINE, "%s%s")
> 		call pargstr (imname)
> 		call pargstr (Memc[tsection])
467c486,487
< 	}
---
> 	} else
> 	    Memc[tsection] = EOS
471a492
> 	DOZERO(mg) = dozero
472a494
> 	DZIM(mg) = NULL
475c497
< 	    if (ccdflag (im, "overscan")) 
---
> 	    if (hdmflag (im, "overscan")) 
477c499,501
< 	    if (ccdflag (im, "flatcor")) 
---
> 	    if (hdmflag (im, "zerocor")) 
> 		DOZERO(mg) = NO
> 	    if (hdmflag (im, "flatcor")) 
479c503
< 	    if (DOBIAS(mg) == NO && DOFLAT(mg) == NO)
---
> 	    if (DOBIAS(mg) == NO && DOZERO(mg) == NO && DOFLAT(mg) == NO)
482,496c506,543
< 	if (PROC(mg) == YES && DOFLAT(mg) == YES) {
< 	    # Get full filter name.
< 	    if (filter[1] == '!')
< 		call hdmgstr (im, filter[2], Memc[filt], SZ_LINE)
< 	    else
< 		call strcpy (filter, Memc[filt], SZ_LINE)
< 
< 	    # Translate to directory identification.
< 	    call strcpy (Memc[filt], Memc[str], SZ_LINE)
< 	    for (i=0;;i=i+1) {
< 		ch = Memc[str+i]
< 		if (ch == EOS || IS_WHITE(ch))
< 		    break
< 		else if (!(IS_ALNUM(ch)||ch=='.'))
< 		    Memc[str+i] = '_'
---
> 	if (PROC(mg) == YES) {
> 	    if (DOZERO(mg) == YES) {
> 		# Set zero calibration.
> 		if (zero[1] == '!') {
> 		    iferr (call imgstr (im, zero[2], ZERONAME(mg),
> 		        LEN_ZERONAME)) {
> 		       call eprintf ("Can't find keyword %s (%s)\n")
> 			   call pargstr (zero[2])
> 			   call pargstr (imname)
> 			ZERONAME(mg) = EOS
> 		    } else {
> 			call sprintf (Memc[section], SZ_LINE, "%s%s")
> 			    call pargstr (ZERONAME(mg))
> 			    call pargstr (Memc[tsection])
> 		    }
> 		} else {
> 		    call strcpy (zero, ZERONAME(mg), LEN_ZERONAME)
> 		    call sprintf (Memc[section], SZ_LINE, "%s%s%s")
> 			call pargstr (ZERONAME(mg))
> 			call pargstr (imname[rootlen+1])
> 			call pargstr (Memc[tsection])
> 		}
> 		if (ZERONAME(mg) != EOS) {
> 		    i = stridxs ("[", Memc[section])
> 		    if (i > 0)
> 			call strcpy (Memc[section], ZERONAME(mg), i-1)
> 		    iferr (DZIM(mg) = immap (Memc[section], READ_ONLY, NULL)) {
> 			DZIM(mg) = NULL
> 			DOZERO(mg) = NO
> 			if (nim == 0)
> 			    call eprintf ("No zero calibration performed.\n")
> 		    }
> 		} else {
> 		    DZIM(mg) = NULL
> 		    DOZERO(mg) = NO
> 		    if (nim == 0)
> 			call eprintf ("No zero calibration performed.\n")
> 		}
498d544
< 	    Memc[str+i] = EOS
500,503c546,549
< 	    # Look for translation menu.
< 	    iferr {
< 		if (caldir[1] == '!')
< 		    call hdmgstr (im, caldir[2], Memc[cdir], SZ_LINE)
---
> 	    if (DOFLAT(mg) == YES) {
> 		# Get full filter name.
> 		if (filter[1] == '!')
> 		    call hdmgstr (im, filter[2], Memc[filt], SZ_LINE)
505c551
< 		    call strcpy (caldir, Memc[cdir], SZ_LINE)
---
> 		    call strcpy (filter, Memc[filt], SZ_LINE)
507,517c553,557
< 		call sprintf (Memc[section], SZ_LINE, "%scal.men")
< 		    call pargstr (Memc[cdir])
< 		fd = open (Memc[section], READ_ONLY, TEXT_FILE)
< 		while (fscan(fd) != EOF) {
< 		    call gargwrd (Memc[section], SZ_LINE)
< 		    call gargwrd (Memc[key], SZ_LINE)
< 		    if (nscan() != 2)
< 			next
< 		    if (streq (Memc[section], Memc[filt]) ||
< 			streq (Memc[key], Memc[filt])) {
< 			call strcpy (Memc[key], Memc[str], SZ_LINE)
---
> 		# Translate to directory identification.
> 		call strcpy (Memc[filt], Memc[str], SZ_LINE)
> 		for (i=0;;i=i+1) {
> 		    ch = Memc[str+i]
> 		    if (ch == EOS || IS_WHITE(ch))
519c559,560
< 		    }
---
> 		    else if (!(IS_ALNUM(ch)||ch=='.'))
> 			Memc[str+i] = '_'
521,538c562,583
< 		call close (fd)
< 	    } then
< 		#call erract (EA_WARN)
< 		;
< 
< 	    # Find calibration data.
< 	    iferr {
< 		call sprintf (Memc[section], SZ_LINE, "%s%s/flat%s.pl")
< 		    call pargstr (Memc[cdir])
< 		    call pargstr (Memc[str])
< 		    call pargstr (Memc[AMPID(mg)])
< 		iferr (dfim = im_pmmap (Memc[section], READ_ONLY, NULL)) {
< 		    if (nim == 0) {
< 			call eprintf (
< 			    "Calibration for filter %s not found (%s%s).\n")
< 			    call pargstr (Memc[filt])
< 			    call pargstr (Memc[cdir])
< 			    call pargstr (Memc[str])
---
> 		Memc[str+i] = EOS
> 
> 		# Look for translation menu.
> 		iferr {
> 		    if (caldir[1] == '!')
> 			call hdmgstr (im, caldir[2], Memc[cdir], SZ_LINE)
> 		    else
> 			call strcpy (caldir, Memc[cdir], SZ_LINE)
> 
> 		    call sprintf (Memc[section], SZ_LINE, "%scal.men")
> 			call pargstr (Memc[cdir])
> 		    fd = open (Memc[section], READ_ONLY, TEXT_FILE)
> 		    while (fscan(fd) != EOF) {
> 			call gargwrd (Memc[section], SZ_LINE)
> 			call gargwrd (Memc[key], SZ_LINE)
> 			if (nscan() != 2)
> 			    next
> 			if (streq (Memc[section], Memc[filt]) ||
> 			    streq (Memc[key], Memc[filt])) {
> 			    call strcpy (Memc[key], Memc[str], SZ_LINE)
> 			    break
> 			}
540c585,591
< 		    call strcpy ("default", Memc[str], SZ_LINE)
---
> 		    call close (fd)
> 		} then
> 		    #call erract (EA_WARN)
> 		    ;
> 
> 		# Find calibration data.
> 		iferr {
545,546c596,597
< 		    iferr (dfim = im_pmmap (Memc[section], READ_ONLY, NULL)) {
< 			if (nim == 0)
---
> 		    iferr (dcim = im_pmmap (Memc[section], READ_ONLY, NULL)) {
> 			if (nim == 0) {
548c599,600
< 				"Default calibration not found (%s%s).\n")
---
> 				"Calibration for filter %s not found (%s%s).\n")
> 				call pargstr (Memc[filt])
550a603,623
> 			}
> 			call strcpy ("default", Memc[str], SZ_LINE)
> 			call sprintf (Memc[section], SZ_LINE, "%s%s/flat%s.pl")
> 			    call pargstr (Memc[cdir])
> 			    call pargstr (Memc[str])
> 			    call pargstr (Memc[AMPID(mg)])
> 			iferr (dcim = im_pmmap (Memc[section],READ_ONLY,NULL)) {
> 			    if (nim == 0)
> 				call eprintf (
> 				    "Default calibration not found (%s%s).\n")
> 				    call pargstr (Memc[cdir])
> 				    call pargstr (Memc[str])
> 			    call erract (EA_ERROR)
> 			}
> 			if (nim == 0)
> 			    call eprintf ("Using default calibration.\n")
> 		    }
> 		    DFIM(mg) = dcim
> 		    iferr (CCDMEAN(mg) = hdmgetr (DFIM(mg), "ccdmean")) {
> 			if (nim == 0)
> 			    call eprintf ("CCDMEAN keyword not found.\n")
553,561d625
< 		    if (nim == 0)
< 			call eprintf ("Using default calibration.\n")
< 		}
< 		DFIM(mg) = dfim
< 		iferr (CCDMEAN(mg) = hdmgetr (DFIM(mg), "ccdmean")) {
< 		    if (nim == 0)
< 			call eprintf ("CCDMEAN keyword not found.\n")
< 		    call erract (EA_ERROR)
< 		}
563,571c627,635
< 		iferr (rval = imgetr (im, "LTM1_1")) {
< 		    call imaddr (im, "LTM1_1", 1./DX(mg))
< 		    call imaddr (im, "LTM2_2", 1./DY(mg))
< 		    call imaddr (im, "LTV1", real (DX1(mg)-1))
< 		    call imaddr (im, "LTV2", 0.)
< 		}
< 		iferr (call yt_match (DFIM(mg), im)) {
< 		    if (nim == 0)
< 			call eprintf (
---
> 		    iferr (rval = imgetr (im, "LTM1_1")) {
> 			call imaddr (im, "LTM1_1", 1./DX(mg))
> 			call imaddr (im, "LTM2_2", 1./DY(mg))
> 			call imaddr (im, "LTV1", real (DX1(mg)-1))
> 			call imaddr (im, "LTV2", 0.)
> 		    }
> 		    iferr (call yt_match (DFIM(mg), im, "physical")) {
> 			if (nim == 0)
> 			    call eprintf (
573,574c637,638
< 		    call erract (EA_ERROR)
< 		}
---
> 			call erract (EA_ERROR)
> 		    }
576,587c640,649
< 		call strcpy (Memc[str], FLATNAME(mg), LEN_FLATNAME)
< 	    } then {
< 		if (DFIM(mg) != NULL)
< 		    call imunmap (DFIM(mg))
< 		DFIM(mg) = NULL
< 		if (nim == 0)
< 		    call eprintf ("No flat field calibration performed.\n")
< 	    }
< 	    if (DFIM(mg) == NULL) {
< 		DOFLAT(mg) = NO
< 		if (DOBIAS(mg) == NO && DOFLAT(mg) == NO)
< 		    PROC(mg) = NO
---
> 		    call strcpy (Memc[str], FLATNAME(mg), LEN_FLATNAME)
> 		} then {
> 		    if (DFIM(mg) != NULL)
> 			call imunmap (DFIM(mg))
> 		    DFIM(mg) = NULL
> 		    if (nim == 0)
> 			call eprintf ("No flat field calibration performed.\n")
> 		}
> 		if (DFIM(mg) == NULL)
> 		    DOFLAT(mg) = NO
588a651,652
> 	    if (DOBIAS(mg)==NO && DOZERO(mg)==NO && DOFLAT(mg)==NO)
> 		PROC(mg) = NO
751c815
< int	i, j, k, ninput, xgap, ygap, gap, x1, x2, y1, y2, clgeti()
---
> int	i, j, k, ninput, xgap, ygap, gap, x1, x2, y1, y2, clgeti(), mg_sort()
752a817
> extern	mg_sort
765a831,834
> 	call qsort (MI_MG(mi,1), ninput, mg_sort)
> 	do i = 1, ninput
> 	    MI_IM(mi,i) = MG_IM(MI_MG(mi,i))
> 
891a961
> 	DOZERO(mgout) = NO
892a963
> 	DZIM(mgout) = NULL
904a976,996
> 
> # MG_SORT -- Sort elements.
> 
> int procedure mg_sort (mi1, mi2)
> 
> pointer	mi1, mi2
> 
> begin
> 	if (CY1(mi1) < CY1(mi2))
> 	    return (-1)
> 	else if (CY1(mi1) > CY1(mi2))
> 	    return (1)
> 	else if (CX1(mi1) < CX1(mi2))
> 	    return (-1)
> 	else if (CX1(mi1) > CX1(mi2))
> 	    return (1)
> 	else
> 	    return (0)
> end
> 
> 
912a1005,1007
> 	    if (DZIM(mg) != NULL)
> 		call imunmap (DZIM(mg))
> 
1004a1100,1101
> 	if (ampid[1] == EOS)
> 	    call hdmgstr (im, "imageid", ampid, maxch) 
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/mscg.gx ./src/mscg.gx
15c15
< pointer	im, dfbuf, inbuf, outbuf
---
> pointer	im, dzbuf, dfbuf, inbuf, outbuf
28a29,31
> $if (datatype != r)
> pointer	imgl2r()
> $endif
60c63
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
75c78,87
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		dfbuf = imgl2i (DFIM(mg), line)
> 		call mscuproc$t (Mems[inbuf], Mem$t[outbuf], nc, bias,
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		call mscuproc$t (Mems[inbuf], Mem$t[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
78c90
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
81c93
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
101c113,114
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
104c117,125
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		call mscproc$t (Mem$t[inbuf], Mem$t[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
> 		dfbuf = imgl2i (DFIM(mg), line)
> 		call mscproc$t (Mem$t[inbuf], Mem$t[outbuf], nc, bias,
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
107c128,129
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
> 
125c147
< pointer	im, dfbuf, inbuf
---
> pointer	im, dzbuf, dfbuf, inbuf
138a161,163
> $if (datatype != r)
> pointer	imgnlr()
> $endif
173c198
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
188c213,223
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call amovl (v, vf, IM_NDIM(im))
> 		stat = imgnli (DFIM(mg), dfbuf, vf)
> 		call mscuproc$t (Mems[inbuf], Mem$t[outbuf], nc, bias,
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call mscuproc$t (Mems[inbuf], Mem$t[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
191c226
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
194c229
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
214c249,251
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call amovl (v, vf, IM_NDIM(im))
217c254,262
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call mscproc$t (Mem$t[inbuf], Mem$t[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
> 		stat = imgnli (DFIM(mg), dfbuf, vf)
> 		call mscproc$t (Mem$t[inbuf], Mem$t[outbuf], nc, bias,
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
220c265
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
236c281
< pointer	im, dfbuf, inbuf, outbuf, inptr, outptr
---
> pointer	im, dzbuf, dfbuf, inbuf, outbuf, inptr, outptr
238c283
< pointer imgs2$t(), imgl2i()
---
> pointer imgs2$t(), imgl2i(), imgl2r()
287c332
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
301c346
< 		inptr = inbuf + (line - y1) * c2
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1)
306c351
< 		inptr = inbuf + (line - y1) * c2 + x1 - 1
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1) + x1 - 1
308c353,354
< 		if (DOFLAT(mg) == YES) {
---
> 		if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
311c357,365
< 			Memi[dfbuf], CCDMEAN(mg))
---
> 			Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 		} else if (DOZERO(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    call mscuproc$t (Mems[inptr], Mem$t[outptr], nc, bias,
> 			Memr[dzbuf], INDEFI, INDEFR)
> 		} else if (DOFLAT(mg) == YES) {
> 		    dfbuf = imgl2i (DFIM(mg), line) + x1 - 1
> 		    call mscuproc$t (Mems[inptr], Mem$t[outptr], nc, bias,
> 			INDEFR, Memi[dfbuf], CCDMEAN(mg))
314c368
< 			INDEFI, INDEFR)
---
> 			INDEFR, INDEFI, INDEFR)
334c388
< 		inptr = inbuf + (line - y1) * c2
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1)
339c393
< 		inptr = inbuf + (line - y1) * c2 + x1 - 1
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1) + x1 - 1
341c395,404
< 		if (DOFLAT(mg) == YES) {
---
> 		if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    dfbuf = imgl2i (DFIM(mg), line) + x1 - 1
> 		    call mscproc$t (Mem$t[inptr], Mem$t[outptr], nc, bias,
> 			Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 		} else if (DOZERO(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    call mscproc$t (Mem$t[inptr], Mem$t[outptr], nc, bias,
> 			Memr[dzbuf], INDEFI, INDEFR)
> 		} else if (DOFLAT(mg) == YES) {
344c407
< 			Memi[dfbuf], CCDMEAN(mg))
---
> 			INDEFR, Memi[dfbuf], CCDMEAN(mg))
347c410
< 			INDEFI, INDEFR)
---
> 			INDEFR, INDEFI, INDEFR)
357c420
< procedure mscuproc$t (in, out, n, bias, flat, ccdmean)
---
> procedure mscuproc$t (in, out, n, bias, zero, flat, ccdmean)
362a426
> real	zero[ARB]
370,376c434,442
< 	if (IS_INDEFR(ccdmean)) {
< 	    if (bias == 0.)
< 		call achts$t (in, out, n)
< 	    else
< 		do i = 1, n
< 		    out[i] = in[i] - bias
< 	} else {
---
> 	if (!IS_INDEFR(ccdmean) && !IS_INDEFR(zero[1])) {
> 	    do i = 1, n {
> 		val = flat[i] / ccdmean
> 		if (val <= 0.)
> 		    val = 1.
> 		out[i] = (in[i] - zero[i] - bias) / val
> 	    }
> 
> 	} else if (!IS_INDEFR(ccdmean)) {
382a449,459
> 
> 	} else if (!IS_INDEFR(zero[1])) {
> 	    do i = 1, n
> 		out[i] = in[i] - zero[i] - bias
> 
> 	} else {
> 	    if (bias == 0.)
> 		call achts$t (in, out, n)
> 	    else
> 		do i = 1, n
> 		    out[i] = in[i] - bias
389c466
< procedure mscproc$t (in, out, n, bias, flat, ccdmean)
---
> procedure mscproc$t (in, out, n, bias, zero, flat, ccdmean)
394a472
> real	zero[ARB]
402,408c480,488
< 	if (IS_INDEFR(ccdmean)) {
< 	    if (bias == 0.)
< 		call amov$t (in, out, n)
< 	    else
< 		do i = 1, n
< 		    out[i] = in[i] - bias
< 	} else {
---
> 	if (!IS_INDEFR(ccdmean) && !IS_INDEFR(zero[1])) {
> 	    do i = 1, n {
> 		val = flat[i] / ccdmean
> 		if (val <= 0.)
> 		    val = 1.
> 		out[i] = (in[i] - zero[i] - bias) / val
> 	    }
> 
> 	} else if (!IS_INDEFR(ccdmean)) {
414a495,505
> 
> 	} else if (!IS_INDEFR(zero[1])) {
> 	    do i = 1, n
> 		out[i] = in[i] - zero[i] - bias
> 
> 	} else {
> 	    if (bias == 0.)
> 		call amov$t (in, out, n)
> 	    else
> 		do i = 1, n
> 		    out[i] = in[i] - bias
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/mscg.x ./src/mscg.x
15c15
< pointer	im, dfbuf, inbuf, outbuf
---
> pointer	im, dzbuf, dfbuf, inbuf, outbuf
18a19
> pointer	imgl2r()
44c45
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
59c60,61
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
62c64,72
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		call mscuprocs (Mems[inbuf], Mems[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
> 		dfbuf = imgl2i (DFIM(mg), line)
> 		call mscuprocs (Mems[inbuf], Mems[outbuf], nc, bias,
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
65c75
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
85c95,104
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		dfbuf = imgl2i (DFIM(mg), line)
> 		call mscprocs (Mems[inbuf], Mems[outbuf], nc, bias,
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		call mscprocs (Mems[inbuf], Mems[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
88c107
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
91c110,111
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
> 
109c129
< pointer	im, dfbuf, inbuf
---
> pointer	im, dzbuf, dfbuf, inbuf
112a133
> pointer	imgnlr()
141c162
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
156c177,187
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call amovl (v, vf, IM_NDIM(im))
> 		stat = imgnli (DFIM(mg), dfbuf, vf)
> 		call mscuprocs (Mems[inbuf], Mems[outbuf], nc, bias,
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call mscuprocs (Mems[inbuf], Mems[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
159c190
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
162c193
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
182c213,215
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call amovl (v, vf, IM_NDIM(im))
185c218,226
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call mscprocs (Mems[inbuf], Mems[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
> 		stat = imgnli (DFIM(mg), dfbuf, vf)
> 		call mscprocs (Mems[inbuf], Mems[outbuf], nc, bias,
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
188c229
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
204c245
< pointer	im, dfbuf, inbuf, outbuf, inptr, outptr
---
> pointer	im, dzbuf, dfbuf, inbuf, outbuf, inptr, outptr
206c247
< pointer imgs2s(), imgl2i()
---
> pointer imgs2s(), imgl2i(), imgl2r()
241c282
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
255c296
< 		inptr = inbuf + (line - y1) * c2
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1)
260c301
< 		inptr = inbuf + (line - y1) * c2 + x1 - 1
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1) + x1 - 1
262c303,304
< 		if (DOFLAT(mg) == YES) {
---
> 		if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
265c307,315
< 			Memi[dfbuf], CCDMEAN(mg))
---
> 			Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 		} else if (DOZERO(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    call mscuprocs (Mems[inptr], Mems[outptr], nc, bias,
> 			Memr[dzbuf], INDEFI, INDEFR)
> 		} else if (DOFLAT(mg) == YES) {
> 		    dfbuf = imgl2i (DFIM(mg), line) + x1 - 1
> 		    call mscuprocs (Mems[inptr], Mems[outptr], nc, bias,
> 			INDEFR, Memi[dfbuf], CCDMEAN(mg))
268c318
< 			INDEFI, INDEFR)
---
> 			INDEFR, INDEFI, INDEFR)
288c338
< 		inptr = inbuf + (line - y1) * c2
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1)
293c343
< 		inptr = inbuf + (line - y1) * c2 + x1 - 1
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1) + x1 - 1
295c345,354
< 		if (DOFLAT(mg) == YES) {
---
> 		if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    dfbuf = imgl2i (DFIM(mg), line) + x1 - 1
> 		    call mscprocs (Mems[inptr], Mems[outptr], nc, bias,
> 			Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 		} else if (DOZERO(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    call mscprocs (Mems[inptr], Mems[outptr], nc, bias,
> 			Memr[dzbuf], INDEFI, INDEFR)
> 		} else if (DOFLAT(mg) == YES) {
298c357
< 			Memi[dfbuf], CCDMEAN(mg))
---
> 			INDEFR, Memi[dfbuf], CCDMEAN(mg))
301c360
< 			INDEFI, INDEFR)
---
> 			INDEFR, INDEFI, INDEFR)
311c370
< procedure mscuprocs (in, out, n, bias, flat, ccdmean)
---
> procedure mscuprocs (in, out, n, bias, zero, flat, ccdmean)
316a376
> real	zero[ARB]
324,330c384,392
< 	if (IS_INDEFR(ccdmean)) {
< 	    if (bias == 0.)
< 		call achtss (in, out, n)
< 	    else
< 		do i = 1, n
< 		    out[i] = in[i] - bias
< 	} else {
---
> 	if (!IS_INDEFR(ccdmean) && !IS_INDEFR(zero[1])) {
> 	    do i = 1, n {
> 		val = flat[i] / ccdmean
> 		if (val <= 0.)
> 		    val = 1.
> 		out[i] = (in[i] - zero[i] - bias) / val
> 	    }
> 
> 	} else if (!IS_INDEFR(ccdmean)) {
336a399,409
> 
> 	} else if (!IS_INDEFR(zero[1])) {
> 	    do i = 1, n
> 		out[i] = in[i] - zero[i] - bias
> 
> 	} else {
> 	    if (bias == 0.)
> 		call achtss (in, out, n)
> 	    else
> 		do i = 1, n
> 		    out[i] = in[i] - bias
343c416
< procedure mscprocs (in, out, n, bias, flat, ccdmean)
---
> procedure mscprocs (in, out, n, bias, zero, flat, ccdmean)
348a422
> real	zero[ARB]
356,362c430,438
< 	if (IS_INDEFR(ccdmean)) {
< 	    if (bias == 0.)
< 		call amovs (in, out, n)
< 	    else
< 		do i = 1, n
< 		    out[i] = in[i] - bias
< 	} else {
---
> 	if (!IS_INDEFR(ccdmean) && !IS_INDEFR(zero[1])) {
> 	    do i = 1, n {
> 		val = flat[i] / ccdmean
> 		if (val <= 0.)
> 		    val = 1.
> 		out[i] = (in[i] - zero[i] - bias) / val
> 	    }
> 
> 	} else if (!IS_INDEFR(ccdmean)) {
368a445,455
> 
> 	} else if (!IS_INDEFR(zero[1])) {
> 	    do i = 1, n
> 		out[i] = in[i] - zero[i] - bias
> 
> 	} else {
> 	    if (bias == 0.)
> 		call amovs (in, out, n)
> 	    else
> 		do i = 1, n
> 		    out[i] = in[i] - bias
383c470
< pointer	im, dfbuf, inbuf, outbuf
---
> pointer	im, dzbuf, dfbuf, inbuf, outbuf
388a476
> pointer	imgl2r()
413c501
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
428c516,517
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
431c520,528
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		call mscuproci (Mems[inbuf], Memi[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
> 		dfbuf = imgl2i (DFIM(mg), line)
> 		call mscuproci (Mems[inbuf], Memi[outbuf], nc, bias,
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
434c531
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
454c551,560
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		dfbuf = imgl2i (DFIM(mg), line)
> 		call mscproci (Memi[inbuf], Memi[outbuf], nc, bias,
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		call mscproci (Memi[inbuf], Memi[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
457c563
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
460c566,567
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
> 
478c585
< pointer	im, dfbuf, inbuf
---
> pointer	im, dzbuf, dfbuf, inbuf
483a591
> pointer	imgnlr()
511c619
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
526c634,636
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call amovl (v, vf, IM_NDIM(im))
529c639,647
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call mscuproci (Mems[inbuf], Memi[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
> 		stat = imgnli (DFIM(mg), dfbuf, vf)
> 		call mscuproci (Mems[inbuf], Memi[outbuf], nc, bias,
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
532c650
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
552c670,672
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call amovl (v, vf, IM_NDIM(im))
555c675,683
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call mscproci (Memi[inbuf], Memi[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
> 		stat = imgnli (DFIM(mg), dfbuf, vf)
> 		call mscproci (Memi[inbuf], Memi[outbuf], nc, bias,
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
558c686
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
574c702
< pointer	im, dfbuf, inbuf, outbuf, inptr, outptr
---
> pointer	im, dzbuf, dfbuf, inbuf, outbuf, inptr, outptr
576c704
< pointer imgs2i(), imgl2i()
---
> pointer imgs2i(), imgl2i(), imgl2r()
613c741
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
627c755
< 		inptr = inbuf + (line - y1) * c2
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1)
632c760
< 		inptr = inbuf + (line - y1) * c2 + x1 - 1
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1) + x1 - 1
634c762,771
< 		if (DOFLAT(mg) == YES) {
---
> 		if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    dfbuf = imgl2i (DFIM(mg), line) + x1 - 1
> 		    call mscuproci (Mems[inptr], Memi[outptr], nc, bias,
> 			Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 		} else if (DOZERO(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    call mscuproci (Mems[inptr], Memi[outptr], nc, bias,
> 			Memr[dzbuf], INDEFI, INDEFR)
> 		} else if (DOFLAT(mg) == YES) {
637c774
< 			Memi[dfbuf], CCDMEAN(mg))
---
> 			INDEFR, Memi[dfbuf], CCDMEAN(mg))
640c777
< 			INDEFI, INDEFR)
---
> 			INDEFR, INDEFI, INDEFR)
660c797
< 		inptr = inbuf + (line - y1) * c2
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1)
665c802
< 		inptr = inbuf + (line - y1) * c2 + x1 - 1
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1) + x1 - 1
667c804,805
< 		if (DOFLAT(mg) == YES) {
---
> 		if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
670c808,816
< 			Memi[dfbuf], CCDMEAN(mg))
---
> 			Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 		} else if (DOZERO(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    call mscproci (Memi[inptr], Memi[outptr], nc, bias,
> 			Memr[dzbuf], INDEFI, INDEFR)
> 		} else if (DOFLAT(mg) == YES) {
> 		    dfbuf = imgl2i (DFIM(mg), line) + x1 - 1
> 		    call mscproci (Memi[inptr], Memi[outptr], nc, bias,
> 			INDEFR, Memi[dfbuf], CCDMEAN(mg))
673c819
< 			INDEFI, INDEFR)
---
> 			INDEFR, INDEFI, INDEFR)
683c829
< procedure mscuproci (in, out, n, bias, flat, ccdmean)
---
> procedure mscuproci (in, out, n, bias, zero, flat, ccdmean)
688a835
> real	zero[ARB]
696,702c843,851
< 	if (IS_INDEFR(ccdmean)) {
< 	    if (bias == 0.)
< 		call achtsi (in, out, n)
< 	    else
< 		do i = 1, n
< 		    out[i] = in[i] - bias
< 	} else {
---
> 	if (!IS_INDEFR(ccdmean) && !IS_INDEFR(zero[1])) {
> 	    do i = 1, n {
> 		val = flat[i] / ccdmean
> 		if (val <= 0.)
> 		    val = 1.
> 		out[i] = (in[i] - zero[i] - bias) / val
> 	    }
> 
> 	} else if (!IS_INDEFR(ccdmean)) {
708a858,868
> 
> 	} else if (!IS_INDEFR(zero[1])) {
> 	    do i = 1, n
> 		out[i] = in[i] - zero[i] - bias
> 
> 	} else {
> 	    if (bias == 0.)
> 		call achtsi (in, out, n)
> 	    else
> 		do i = 1, n
> 		    out[i] = in[i] - bias
715c875
< procedure mscproci (in, out, n, bias, flat, ccdmean)
---
> procedure mscproci (in, out, n, bias, zero, flat, ccdmean)
720a881
> real	zero[ARB]
728,734c889,897
< 	if (IS_INDEFR(ccdmean)) {
< 	    if (bias == 0.)
< 		call amovi (in, out, n)
< 	    else
< 		do i = 1, n
< 		    out[i] = in[i] - bias
< 	} else {
---
> 	if (!IS_INDEFR(ccdmean) && !IS_INDEFR(zero[1])) {
> 	    do i = 1, n {
> 		val = flat[i] / ccdmean
> 		if (val <= 0.)
> 		    val = 1.
> 		out[i] = (in[i] - zero[i] - bias) / val
> 	    }
> 
> 	} else if (!IS_INDEFR(ccdmean)) {
740a904,914
> 
> 	} else if (!IS_INDEFR(zero[1])) {
> 	    do i = 1, n
> 		out[i] = in[i] - zero[i] - bias
> 
> 	} else {
> 	    if (bias == 0.)
> 		call amovi (in, out, n)
> 	    else
> 		do i = 1, n
> 		    out[i] = in[i] - bias
755c929
< pointer	im, dfbuf, inbuf, outbuf
---
> pointer	im, dzbuf, dfbuf, inbuf, outbuf
760a935
> pointer	imgl2r()
786c961
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
801c976,985
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		dfbuf = imgl2i (DFIM(mg), line)
> 		call mscuprocl (Mems[inbuf], Meml[outbuf], nc, bias,
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		call mscuprocl (Mems[inbuf], Meml[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
804c988
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
807c991
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
827c1011,1012
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
830c1015,1023
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		call mscprocl (Meml[inbuf], Meml[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
> 		dfbuf = imgl2i (DFIM(mg), line)
> 		call mscprocl (Meml[inbuf], Meml[outbuf], nc, bias,
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
833c1026,1027
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
> 
851c1045
< pointer	im, dfbuf, inbuf
---
> pointer	im, dzbuf, dfbuf, inbuf
856a1051
> pointer	imgnlr()
885c1080
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
900c1095,1097
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call amovl (v, vf, IM_NDIM(im))
903c1100,1108
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call mscuprocl (Mems[inbuf], Meml[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
> 		stat = imgnli (DFIM(mg), dfbuf, vf)
> 		call mscuprocl (Mems[inbuf], Meml[outbuf], nc, bias,
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
906c1111
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
926c1131,1133
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call amovl (v, vf, IM_NDIM(im))
929c1136,1144
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call mscprocl (Meml[inbuf], Meml[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
> 		stat = imgnli (DFIM(mg), dfbuf, vf)
> 		call mscprocl (Meml[inbuf], Meml[outbuf], nc, bias,
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
932c1147
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
948c1163
< pointer	im, dfbuf, inbuf, outbuf, inptr, outptr
---
> pointer	im, dzbuf, dfbuf, inbuf, outbuf, inptr, outptr
950c1165
< pointer imgs2l(), imgl2i()
---
> pointer imgs2l(), imgl2i(), imgl2r()
987c1202
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
1001c1216
< 		inptr = inbuf + (line - y1) * c2
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1)
1006c1221
< 		inptr = inbuf + (line - y1) * c2 + x1 - 1
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1) + x1 - 1
1008c1223,1224
< 		if (DOFLAT(mg) == YES) {
---
> 		if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
1011c1227,1235
< 			Memi[dfbuf], CCDMEAN(mg))
---
> 			Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 		} else if (DOZERO(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    call mscuprocl (Mems[inptr], Meml[outptr], nc, bias,
> 			Memr[dzbuf], INDEFI, INDEFR)
> 		} else if (DOFLAT(mg) == YES) {
> 		    dfbuf = imgl2i (DFIM(mg), line) + x1 - 1
> 		    call mscuprocl (Mems[inptr], Meml[outptr], nc, bias,
> 			INDEFR, Memi[dfbuf], CCDMEAN(mg))
1014c1238
< 			INDEFI, INDEFR)
---
> 			INDEFR, INDEFI, INDEFR)
1034c1258
< 		inptr = inbuf + (line - y1) * c2
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1)
1039c1263
< 		inptr = inbuf + (line - y1) * c2 + x1 - 1
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1) + x1 - 1
1041c1265,1266
< 		if (DOFLAT(mg) == YES) {
---
> 		if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
1044c1269,1277
< 			Memi[dfbuf], CCDMEAN(mg))
---
> 			Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 		} else if (DOZERO(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    call mscprocl (Meml[inptr], Meml[outptr], nc, bias,
> 			Memr[dzbuf], INDEFI, INDEFR)
> 		} else if (DOFLAT(mg) == YES) {
> 		    dfbuf = imgl2i (DFIM(mg), line) + x1 - 1
> 		    call mscprocl (Meml[inptr], Meml[outptr], nc, bias,
> 			INDEFR, Memi[dfbuf], CCDMEAN(mg))
1047c1280
< 			INDEFI, INDEFR)
---
> 			INDEFR, INDEFI, INDEFR)
1057c1290
< procedure mscuprocl (in, out, n, bias, flat, ccdmean)
---
> procedure mscuprocl (in, out, n, bias, zero, flat, ccdmean)
1062a1296
> real	zero[ARB]
1070,1076c1304,1312
< 	if (IS_INDEFR(ccdmean)) {
< 	    if (bias == 0.)
< 		call achtsl (in, out, n)
< 	    else
< 		do i = 1, n
< 		    out[i] = in[i] - bias
< 	} else {
---
> 	if (!IS_INDEFR(ccdmean) && !IS_INDEFR(zero[1])) {
> 	    do i = 1, n {
> 		val = flat[i] / ccdmean
> 		if (val <= 0.)
> 		    val = 1.
> 		out[i] = (in[i] - zero[i] - bias) / val
> 	    }
> 
> 	} else if (!IS_INDEFR(ccdmean)) {
1082a1319,1329
> 
> 	} else if (!IS_INDEFR(zero[1])) {
> 	    do i = 1, n
> 		out[i] = in[i] - zero[i] - bias
> 
> 	} else {
> 	    if (bias == 0.)
> 		call achtsl (in, out, n)
> 	    else
> 		do i = 1, n
> 		    out[i] = in[i] - bias
1089c1336
< procedure mscprocl (in, out, n, bias, flat, ccdmean)
---
> procedure mscprocl (in, out, n, bias, zero, flat, ccdmean)
1094a1342
> real	zero[ARB]
1102,1108c1350,1358
< 	if (IS_INDEFR(ccdmean)) {
< 	    if (bias == 0.)
< 		call amovl (in, out, n)
< 	    else
< 		do i = 1, n
< 		    out[i] = in[i] - bias
< 	} else {
---
> 	if (!IS_INDEFR(ccdmean) && !IS_INDEFR(zero[1])) {
> 	    do i = 1, n {
> 		val = flat[i] / ccdmean
> 		if (val <= 0.)
> 		    val = 1.
> 		out[i] = (in[i] - zero[i] - bias) / val
> 	    }
> 
> 	} else if (!IS_INDEFR(ccdmean)) {
1114a1365,1375
> 
> 	} else if (!IS_INDEFR(zero[1])) {
> 	    do i = 1, n
> 		out[i] = in[i] - zero[i] - bias
> 
> 	} else {
> 	    if (bias == 0.)
> 		call amovl (in, out, n)
> 	    else
> 		do i = 1, n
> 		    out[i] = in[i] - bias
1129c1390
< pointer	im, dfbuf, inbuf, outbuf
---
> pointer	im, dzbuf, dfbuf, inbuf, outbuf
1160c1421
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
1175c1436,1437
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
1178c1440,1448
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		call mscuprocr (Mems[inbuf], Memr[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
> 		dfbuf = imgl2i (DFIM(mg), line)
> 		call mscuprocr (Mems[inbuf], Memr[outbuf], nc, bias,
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
1181c1451
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
1201c1471,1472
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
1204c1475,1483
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		call mscprocr (Memr[inbuf], Memr[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
> 		dfbuf = imgl2i (DFIM(mg), line)
> 		call mscprocr (Memr[inbuf], Memr[outbuf], nc, bias,
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
1207c1486,1487
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
> 
1225c1505
< pointer	im, dfbuf, inbuf
---
> pointer	im, dzbuf, dfbuf, inbuf
1259c1539
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
1274c1554,1564
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call amovl (v, vf, IM_NDIM(im))
> 		stat = imgnli (DFIM(mg), dfbuf, vf)
> 		call mscuprocr (Mems[inbuf], Memr[outbuf], nc, bias,
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call mscuprocr (Mems[inbuf], Memr[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
1277c1567
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
1280c1570
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
1300c1590,1600
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call amovl (v, vf, IM_NDIM(im))
> 		stat = imgnli (DFIM(mg), dfbuf, vf)
> 		call mscprocr (Memr[inbuf], Memr[outbuf], nc, bias,
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call mscprocr (Memr[inbuf], Memr[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
1303c1603
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
1306c1606
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
1322c1622
< pointer	im, dfbuf, inbuf, outbuf, inptr, outptr
---
> pointer	im, dzbuf, dfbuf, inbuf, outbuf, inptr, outptr
1324c1624
< pointer imgs2r(), imgl2i()
---
> pointer imgs2r(), imgl2i(), imgl2r()
1361c1661
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
1375c1675
< 		inptr = inbuf + (line - y1) * c2
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1)
1380c1680
< 		inptr = inbuf + (line - y1) * c2 + x1 - 1
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1) + x1 - 1
1382c1682,1683
< 		if (DOFLAT(mg) == YES) {
---
> 		if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
1385c1686,1694
< 			Memi[dfbuf], CCDMEAN(mg))
---
> 			Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 		} else if (DOZERO(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    call mscuprocr (Mems[inptr], Memr[outptr], nc, bias,
> 			Memr[dzbuf], INDEFI, INDEFR)
> 		} else if (DOFLAT(mg) == YES) {
> 		    dfbuf = imgl2i (DFIM(mg), line) + x1 - 1
> 		    call mscuprocr (Mems[inptr], Memr[outptr], nc, bias,
> 			INDEFR, Memi[dfbuf], CCDMEAN(mg))
1388c1697
< 			INDEFI, INDEFR)
---
> 			INDEFR, INDEFI, INDEFR)
1408c1717
< 		inptr = inbuf + (line - y1) * c2
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1)
1413c1722
< 		inptr = inbuf + (line - y1) * c2 + x1 - 1
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1) + x1 - 1
1415c1724,1725
< 		if (DOFLAT(mg) == YES) {
---
> 		if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
1418c1728,1736
< 			Memi[dfbuf], CCDMEAN(mg))
---
> 			Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 		} else if (DOZERO(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    call mscprocr (Memr[inptr], Memr[outptr], nc, bias,
> 			Memr[dzbuf], INDEFI, INDEFR)
> 		} else if (DOFLAT(mg) == YES) {
> 		    dfbuf = imgl2i (DFIM(mg), line) + x1 - 1
> 		    call mscprocr (Memr[inptr], Memr[outptr], nc, bias,
> 			INDEFR, Memi[dfbuf], CCDMEAN(mg))
1421c1739
< 			INDEFI, INDEFR)
---
> 			INDEFR, INDEFI, INDEFR)
1431c1749
< procedure mscuprocr (in, out, n, bias, flat, ccdmean)
---
> procedure mscuprocr (in, out, n, bias, zero, flat, ccdmean)
1436a1755
> real	zero[ARB]
1444,1450c1763,1771
< 	if (IS_INDEFR(ccdmean)) {
< 	    if (bias == 0.)
< 		call achtsr (in, out, n)
< 	    else
< 		do i = 1, n
< 		    out[i] = in[i] - bias
< 	} else {
---
> 	if (!IS_INDEFR(ccdmean) && !IS_INDEFR(zero[1])) {
> 	    do i = 1, n {
> 		val = flat[i] / ccdmean
> 		if (val <= 0.)
> 		    val = 1.
> 		out[i] = (in[i] - zero[i] - bias) / val
> 	    }
> 
> 	} else if (!IS_INDEFR(ccdmean)) {
1456a1778,1788
> 
> 	} else if (!IS_INDEFR(zero[1])) {
> 	    do i = 1, n
> 		out[i] = in[i] - zero[i] - bias
> 
> 	} else {
> 	    if (bias == 0.)
> 		call achtsr (in, out, n)
> 	    else
> 		do i = 1, n
> 		    out[i] = in[i] - bias
1463c1795
< procedure mscprocr (in, out, n, bias, flat, ccdmean)
---
> procedure mscprocr (in, out, n, bias, zero, flat, ccdmean)
1468a1801
> real	zero[ARB]
1476,1482c1809,1817
< 	if (IS_INDEFR(ccdmean)) {
< 	    if (bias == 0.)
< 		call amovr (in, out, n)
< 	    else
< 		do i = 1, n
< 		    out[i] = in[i] - bias
< 	} else {
---
> 	if (!IS_INDEFR(ccdmean) && !IS_INDEFR(zero[1])) {
> 	    do i = 1, n {
> 		val = flat[i] / ccdmean
> 		if (val <= 0.)
> 		    val = 1.
> 		out[i] = (in[i] - zero[i] - bias) / val
> 	    }
> 
> 	} else if (!IS_INDEFR(ccdmean)) {
1488a1824,1834
> 
> 	} else if (!IS_INDEFR(zero[1])) {
> 	    do i = 1, n
> 		out[i] = in[i] - zero[i] - bias
> 
> 	} else {
> 	    if (bias == 0.)
> 		call amovr (in, out, n)
> 	    else
> 		do i = 1, n
> 		    out[i] = in[i] - bias
1503c1849
< pointer	im, dfbuf, inbuf, outbuf
---
> pointer	im, dzbuf, dfbuf, inbuf, outbuf
1508a1855
> pointer	imgl2r()
1534c1881
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
1549c1896,1897
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
1552c1900,1908
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		call mscuprocd (Mems[inbuf], Memd[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
> 		dfbuf = imgl2i (DFIM(mg), line)
> 		call mscuprocd (Mems[inbuf], Memd[outbuf], nc, bias,
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
1555c1911
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
1575c1931,1932
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
1578c1935,1943
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		dzbuf = imgl2r (DZIM(mg), line)
> 		call mscprocd (Memd[inbuf], Memd[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
> 		dfbuf = imgl2i (DFIM(mg), line)
> 		call mscprocd (Memd[inbuf], Memd[outbuf], nc, bias,
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
1581c1946,1947
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
> 
1599c1965
< pointer	im, dfbuf, inbuf
---
> pointer	im, dzbuf, dfbuf, inbuf
1604a1971
> pointer	imgnlr()
1633c2000
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
1648c2015,2025
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call amovl (v, vf, IM_NDIM(im))
> 		stat = imgnli (DFIM(mg), dfbuf, vf)
> 		call mscuprocd (Mems[inbuf], Memd[outbuf], nc, bias,
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call mscuprocd (Mems[inbuf], Memd[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
1651c2028
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
1654c2031
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
1674c2051,2053
< 	    if (DOFLAT(mg) == YES) {
---
> 	    if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call amovl (v, vf, IM_NDIM(im))
1677c2056,2064
< 		    Memi[dfbuf], CCDMEAN(mg))
---
> 		    Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 	    } else if (DOZERO(mg) == YES) {
> 		stat = imgnlr (DZIM(mg), dzbuf, vf)
> 		call mscprocd (Memd[inbuf], Memd[outbuf], nc, bias,
> 		    Memr[dzbuf], INDEFI, INDEFR)
> 	    } else if (DOFLAT(mg) == YES) {
> 		stat = imgnli (DFIM(mg), dfbuf, vf)
> 		call mscprocd (Memd[inbuf], Memd[outbuf], nc, bias,
> 		    INDEFR, Memi[dfbuf], CCDMEAN(mg))
1680c2067
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
1696c2083
< pointer	im, dfbuf, inbuf, outbuf, inptr, outptr
---
> pointer	im, dzbuf, dfbuf, inbuf, outbuf, inptr, outptr
1698c2085
< pointer imgs2d(), imgl2i()
---
> pointer imgs2d(), imgl2i(), imgl2r()
1735c2122
< 		    INDEFI, INDEFR)
---
> 		    INDEFR, INDEFI, INDEFR)
1749c2136
< 		inptr = inbuf + (line - y1) * c2
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1)
1754c2141
< 		inptr = inbuf + (line - y1) * c2 + x1 - 1
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1) + x1 - 1
1756c2143,2152
< 		if (DOFLAT(mg) == YES) {
---
> 		if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    dfbuf = imgl2i (DFIM(mg), line) + x1 - 1
> 		    call mscuprocd (Mems[inptr], Memd[outptr], nc, bias,
> 			Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 		} else if (DOZERO(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    call mscuprocd (Mems[inptr], Memd[outptr], nc, bias,
> 			Memr[dzbuf], INDEFI, INDEFR)
> 		} else if (DOFLAT(mg) == YES) {
1759c2155
< 			Memi[dfbuf], CCDMEAN(mg))
---
> 			INDEFR, Memi[dfbuf], CCDMEAN(mg))
1762c2158
< 			INDEFI, INDEFR)
---
> 			INDEFR, INDEFI, INDEFR)
1782c2178
< 		inptr = inbuf + (line - y1) * c2
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1)
1787c2183
< 		inptr = inbuf + (line - y1) * c2 + x1 - 1
---
> 		inptr = inbuf + (line - y1) * (c2 - c1 + 1) + x1 - 1
1789c2185,2194
< 		if (DOFLAT(mg) == YES) {
---
> 		if (DOZERO(mg) == YES && DOFLAT(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    dfbuf = imgl2i (DFIM(mg), line) + x1 - 1
> 		    call mscprocd (Memd[inptr], Memd[outptr], nc, bias,
> 			Memr[dzbuf], Memi[dfbuf], CCDMEAN(mg))
> 		} else if (DOZERO(mg) == YES) {
> 		    dzbuf = imgl2r (DZIM(mg), line) + x1 - 1
> 		    call mscprocd (Memd[inptr], Memd[outptr], nc, bias,
> 			Memr[dzbuf], INDEFI, INDEFR)
> 		} else if (DOFLAT(mg) == YES) {
1792c2197
< 			Memi[dfbuf], CCDMEAN(mg))
---
> 			INDEFR, Memi[dfbuf], CCDMEAN(mg))
1795c2200
< 			INDEFI, INDEFR)
---
> 			INDEFR, INDEFI, INDEFR)
1805c2210
< procedure mscuprocd (in, out, n, bias, flat, ccdmean)
---
> procedure mscuprocd (in, out, n, bias, zero, flat, ccdmean)
1810a2216
> real	zero[ARB]
1818,1824c2224,2232
< 	if (IS_INDEFR(ccdmean)) {
< 	    if (bias == 0.)
< 		call achtsd (in, out, n)
< 	    else
< 		do i = 1, n
< 		    out[i] = in[i] - bias
< 	} else {
---
> 	if (!IS_INDEFR(ccdmean) && !IS_INDEFR(zero[1])) {
> 	    do i = 1, n {
> 		val = flat[i] / ccdmean
> 		if (val <= 0.)
> 		    val = 1.
> 		out[i] = (in[i] - zero[i] - bias) / val
> 	    }
> 
> 	} else if (!IS_INDEFR(ccdmean)) {
1830a2239,2249
> 
> 	} else if (!IS_INDEFR(zero[1])) {
> 	    do i = 1, n
> 		out[i] = in[i] - zero[i] - bias
> 
> 	} else {
> 	    if (bias == 0.)
> 		call achtsd (in, out, n)
> 	    else
> 		do i = 1, n
> 		    out[i] = in[i] - bias
1837c2256
< procedure mscprocd (in, out, n, bias, flat, ccdmean)
---
> procedure mscprocd (in, out, n, bias, zero, flat, ccdmean)
1842a2262
> real	zero[ARB]
1850,1856c2270,2278
< 	if (IS_INDEFR(ccdmean)) {
< 	    if (bias == 0.)
< 		call amovd (in, out, n)
< 	    else
< 		do i = 1, n
< 		    out[i] = in[i] - bias
< 	} else {
---
> 	if (!IS_INDEFR(ccdmean) && !IS_INDEFR(zero[1])) {
> 	    do i = 1, n {
> 		val = flat[i] / ccdmean
> 		if (val <= 0.)
> 		    val = 1.
> 		out[i] = (in[i] - zero[i] - bias) / val
> 	    }
> 
> 	} else if (!IS_INDEFR(ccdmean)) {
1862a2285,2295
> 
> 	} else if (!IS_INDEFR(zero[1])) {
> 	    do i = 1, n
> 		out[i] = in[i] - zero[i] - bias
> 
> 	} else {
> 	    if (bias == 0.)
> 		call amovd (in, out, n)
> 	    else
> 		do i = 1, n
> 		    out[i] = in[i] - bias
Only in ./src/oldimexam: mos.log
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/oldimexam/t_imexam.x ./src/oldimexam/t_imexam.x
36c36,37
<         call clgstr    ("instrument",  Memc[instrument],  SZ_FNAME)
---
>         #call clgstr    ("instrument",  Memc[instrument],  SZ_FNAME)
> 	Memc[instrument] = EOS
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/sigm2.gx ./src/sigm2.gx
280c280
< 		    call si_samples (Mems[rawline], Mems[SI_BUF(si,i)],
---
> 		    call zi_samples (Mems[rawline], Mems[SI_BUF(si,i)],
325c325,607
< $for (sr)
---
> 
> # SIGM2I -- Get a line of type int from a scaled image.  Block averaging is
> # done by a subprocedure; this procedure gets a line from a possibly block
> # averaged image and if necessary interpolates it to the grid points of the
> # output line.
> 
> pointer procedure yigm2i (si, lineno)
> 
> pointer	si		# pointer to SI descriptor
> int	lineno
> 
> pointer	rawline, tempp, gp
> int	i, new_y[2], tempi, curbuf, altbuf
> int	nraw, npix, nblks_y, ybavg, x1, x2
> real	x, y, weight_1, weight_2
> pointer	si_blmavgi()
> errchk	si_blmavgi
> 
> begin
> 	nraw = IM_LEN(SI_IM(si),1)
> 	npix = SI_NPIX(si,1)
> 
> 	# Determine the range of X (in pixels on the block averaged input image)
> 	# required for the interpolator.
> 
> 	gp = SI_GRID(si,1)
> 	x1 = SI_XOFF(si)
> 	x = Memr[gp+npix-1]
> 	x2 = x1 + int(x)
> 	if (INTVAL(x,SI_TOL))
> 	    x2 = x2 - 1
> 	x2 = max (x1 + 1, x2)
> 
> 	gp = SI_GRID(si,2)
> 	y = Memr[gp+lineno-1]
> 
> 	# The following is an optimization provided for the case when it is
> 	# not necessary to interpolate in either X or Y.  Block averaging is
> 	# permitted.
> 
> 	if (SI_INTERP(si,1) == NO && SI_INTERP(si,2) == NO)
> 	    return (si_blmavgi (SI_IM(si), SI_FP(si), x1, x2, int(y),
> 		SI_BAVG(si,1), SI_BAVG(si,2), SI_ORDER(si)))
> 
> 	# If we are interpolating in Y two buffers are required, one for each
> 	# of the two input image lines required to interpolate in Y.  The lines
> 	# stored in these buffers are interpolated in X to the output grid but
> 	# not in Y.  Both buffers are not required if we are not interpolating
> 	# in Y, but we use them anyhow to simplify the code.
> 
> 	if (SI_INIT(si) == YES) {
> 	    do i = 1, 2 {
> 		if (SI_BUF(si,i) != NULL)
> 		    call mfree (SI_BUF(si,i), SI_TYBUF(si))
> 		call malloc (SI_BUF(si,i), npix, TY_INT)
> 		SI_TYBUF(si) = TY_INT
> 		SI_BUFY(si,i) = NOTSET
> 	    }
> 	    if (OUTBUF(si) != NULL)
> 		call mfree (OUTBUF(si), SI_TYBUF(si))
> 	    call malloc (OUTBUF(si), npix, TY_INT)
> 	    SI_INIT(si) = NO
> 	}
> 
> 	# If the Y value of the new line is not in range of the contents of the
> 	# current line buffers, refill one or both buffers.  To refill we must
> 	# read a (possibly block averaged) input line and interpolate it onto
> 	# the X grid.  The X and Y values herein are in the coordinate system
> 	# of the (possibly block averaged) input image.
> 
> 	new_y[1] = int(y)
> 	new_y[2] = int(y) + 1
> 
> 	# Get the pair of lines whose integral Y values form an interval
> 	# containing the fractional Y value of the output line.  Sometimes the
> 	# desired line will happen to be in the other buffer already, in which
> 	# case we just have to swap buffers.  Often the new line will be the
> 	# current line, in which case nothing is done.  This latter case occurs
> 	# frequently when the magnification ratio is large.
> 
> 	curbuf = 1
> 	altbuf = 2
> 
> 	do i = 1, 2 {
> 	    if (new_y[i] == SI_BUFY(si,i)) {
> 		;
> 	    } else if (new_y[i] == SI_BUFY(si,altbuf)) {
> 		SWAPP (SI_BUF(si,1), SI_BUF(si,2))
> 		SWAPI (SI_BUFY(si,1), SI_BUFY(si,2))
> 
> 	    } else {
> 		# Get line and interpolate onto output grid.  If interpolation
> 		# is not required merely copy data out.  This code is set up
> 		# to always use two buffers; in effect, there is one buffer of
> 		# look ahead, even when Y[i] is integral.  This means that we
> 		# will go out of bounds by one line at the top of the image.
> 		# This is handled by copying the last line.
> 
> 		ybavg = SI_BAVG(si,2)
> 		nblks_y = (IM_LEN (SI_IM(si), 2) + ybavg-1) / ybavg
> 		if (new_y[i] <= nblks_y)
> 		    rawline = si_blmavgi (SI_IM(si), SI_FP(si), x1, x2,
> 			new_y[i], SI_BAVG(si,1), SI_BAVG(si,2), SI_ORDER(si))
> 
> 		if (SI_INTERP(si,1) == NO) {
> 		    call amovi (Memi[rawline], Memi[SI_BUF(si,i)], npix)
> 		} else if (SI_ORDER(si) == 0) {
> 		    call zi_samplei (Memi[rawline], Memi[SI_BUF(si,i)],
> 			Memr[SI_GRID(si,1)], npix)
> 		} else if (SI_ORDER(si) == -1) {
> 		    call zi_maxi (Memi[rawline], nraw,
> 		    	Memr[SI_GRID(si,1)], Memi[SI_BUF(si,i)], npix)
> 		} else {
> 		    call aluii (Memi[rawline], Memi[SI_BUF(si,i)],
> 			Memr[SI_GRID(si,1)], npix)
> 		}
> 
> 		SI_BUFY(si,i) = new_y[i]
> 	    }
> 
> 	    SWAPI (altbuf, curbuf)
> 	}
> 
> 	# We now have two line buffers straddling the output Y value,
> 	# interpolated to the X grid of the output line.  To complete the
> 	# bilinear interpolation operation we take a weighted sum of the two
> 	# lines.  If the range from SI_BUFY(si,1) to SI_BUFY(si,2) is repeatedly
> 	# interpolated in Y no additional i/o occurs and the linear
> 	# interpolation operation (ALUI) does not have to be repeated (only the
> 	# weighted sum is required).  If the distance of Y from one of the
> 	# buffers is zero then we do not even have to take a weighted sum.
> 	# This is not unusual because we may be called with a magnification
> 	# of 1.0 in Y.
> 
> 	weight_1 = 1.0 - (y - SI_BUFY(si,1))
> 	weight_2 = 1.0 - weight_1
> 
> 	if (weight_1 < SI_TOL)
> 	    return (SI_BUF(si,2))
> 	else if (weight_2 < SI_TOL || SI_ORDER(si) == 0)
> 	    return (SI_BUF(si,1))
> 	else if (SI_ORDER(si) == -1) {
> 	    call amaxi (Memi[SI_BUF(si,1)], Memi[SI_BUF(si,2)],
> 		Memi[OUTBUF(si)], npix)
> 	    return (OUTBUF(si))
> 	} else {
> 	    call awsui (Memi[SI_BUF(si,1)], Memi[SI_BUF(si,2)],
> 		Memi[OUTBUF(si)], npix, weight_1, weight_2)
> 	    return (OUTBUF(si))
> 	}
> end
> 
> 
> # SI_BLMAVGI -- Get a line from a block averaged image of type integer.
> # For example, block averaging by a factor of 2 means that pixels 1 and 2
> # are averaged to produce the first output pixel, 3 and 4 are averaged to
> # produce the second output pixel, and so on.  If the length of an axis
> # is not an integral multiple of the block size then the last pixel in the
> # last block will be replicated to fill out the block; the average is still
> # defined even if a block is not full.
> 
> pointer procedure si_blmavgi (im, fp, x1, x2, y, xbavg, ybavg, order)
> 
> pointer	im			# input image
> pointer	fp			# fixpix structure
> int	x1, x2			# range of x blocks to be read
> int	y			# y block to be read
> int	xbavg, ybavg		# X and Y block averaging factors
> int	order			# averaging option
> 
> real	sum
> int	blkmax
> pointer	sp, a, b
> int	nblks_x, nblks_y, ncols, nlines, xoff, blk1, blk2, i, j, k
> int	first_line, nlines_in_sum, npix, nfull_blks, count
> pointer	xt_fpi()
> errchk	xt_fpi
> 
> begin
> 	call smark (sp)
> 
> 	ncols  = IM_LEN(im,1)
> 	nlines = IM_LEN(im,2)
> 	xoff   = (x1 - 1) * xbavg + 1
> 	npix   = min (ncols, xoff + (x2 - x1 + 1) * xbavg - 1) - xoff + 1
> 
> 	if ((xbavg < 1) || (ybavg < 1))
> 	    call error (1, "si_blmavg: illegal block size")
> 	else if (x1 < 1 || x2 > ncols)
> 	    call error (2, "si_blmavg: column index out of bounds")
> 	else if ((xbavg == 1) && (ybavg == 1))
> 	    return (xt_fpi (fp, im, y, NULL) + xoff - 1)
> 
> 	nblks_x = (npix   + xbavg-1) / xbavg
> 	nblks_y = (nlines + ybavg-1) / ybavg
> 
> 	if (y < 1 || y > nblks_y)
> 	    call error (2, "si_blmavg: block number out of range")
> 
> 	if (ybavg > 1) {
> 	    call salloc (b, nblks_x, TY_LONG)
> 	    call aclrl (Meml[b], nblks_x)
> 	    nlines_in_sum = 0
> 	}
> 
> 	# Read and accumulate all input lines in the block.
> 	first_line = (y - 1) * ybavg + 1
> 
> 	do i = first_line, min (nlines, first_line + ybavg - 1) {
> 	    # Get line from input image.
> 	    a = xt_fpi (fp, im, i, NULL) + xoff - 1
> 
> 	    # Block average line in X.
> 	    if (xbavg > 1) {
> 		# First block average only the full blocks.
> 		nfull_blks = npix / xbavg
> 		if (order == -1) {
> 		    blk1 = a
> 		    do j = 1, nfull_blks {
> 			blk2 = blk1 + xbavg
> 			blkmax = Memi[blk1]
> 			do k = blk1+1, blk2-1
> 			    blkmax = max (blkmax, Memi[k])
> 			Memi[a+j-1] = blkmax
> 			blk1 = blk2
> 		    }
> 		} else
> 		    call abavi (Memi[a], Memi[a], nfull_blks, xbavg)
> 
> 		# Now average the final partial block, if any.
> 		if (nfull_blks < nblks_x) {
> 		    if (order == -1) {
> 			blkmax = Memi[blk1]
> 			do k = blk1+1, a+npix-1
> 			    blkmax = max (blkmax, Memi[k])
> 			Memi[a+j-1] = blkmax
> 		    } else {
> 			sum = 0.0
> 			count = 0
> 			do j = nfull_blks * xbavg + 1, npix {
> 			    sum = sum + Memi[a+j-1]
> 			    count = count + 1
> 			}
> 			Memi[a+nblks_x-1] = sum / count
> 		    }
> 		}
> 	    }
> 
> 	    # Add line into block sum.  Keep track of number of lines in sum
> 	    # so that we can compute block average later.
> 
> 	    if (ybavg > 1) {
> 		if (order == -1) {
> 		    do j = 0, nblks_x-1
> 			Meml[b+j] = max (Meml[b+j], long (Memi[a+j]))
> 		} else {
> 		    do j = 0, nblks_x-1
> 			Meml[b+j] = Meml[b+j] + Memi[a+j]
> 		    nlines_in_sum = nlines_in_sum + 1
> 		}
> 	    }
> 	}
> 
> 	# Compute the block average in Y from the sum of all lines block
> 	# averaged in X.  Overwrite buffer A, the buffer returned by IMIO.
> 	# This is kosher because the block averaged line is never longer
> 	# than an input line.
> 
> 	if (ybavg > 1) {
> 	    if (order == -1) {
> 		do i = 0, nblks_x-1
> 		    Memi[a+i] = Meml[b+i]
> 	    } else {
> 		do i = 0, nblks_x-1
> 		    Memi[a+i] = Meml[b+i] / real(nlines_in_sum)
> 	    }
> 	}
> 
> 	call sfree (sp)
> 	return (a)
> end
> 
> $for (sir)
434c716
< 		    call si_sample$t (Mem$t[rawline], Mem$t[SI_BUF(si,i)],
---
> 		    call zi_sample$t (Mem$t[rawline], Mem$t[SI_BUF(si,i)],
932a1215,1228
> # SI_SAMPLE -- Resample a line via nearest neighbor, rather than linear
> # interpolation (ALUI).  The calling sequence is the same as for ALUII.
> 
> procedure zi_sample$t (a, b, x, npix)
> 
> PIXEL	a[ARB], b[ARB]		# input, output data arrays
> real	x[ARB]			# sample grid
> int	npix, i
> 
> begin
> 	do i = 1, npix
> 	    b[i] = a[int(x[i])]
> end
> 
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/sigm2.x ./src/sigm2.x
280c280
< 		    call si_samples (Mems[rawline], Mems[SI_BUF(si,i)],
---
> 		    call zi_samples (Mems[rawline], Mems[SI_BUF(si,i)],
325a326,1179
> # SIGM2I -- Get a line of type int from a scaled image.  Block averaging is
> # done by a subprocedure; this procedure gets a line from a possibly block
> # averaged image and if necessary interpolates it to the grid points of the
> # output line.
> 
> pointer procedure yigm2i (si, lineno)
> 
> pointer	si		# pointer to SI descriptor
> int	lineno
> 
> pointer	rawline, tempp, gp
> int	i, new_y[2], tempi, curbuf, altbuf
> int	nraw, npix, nblks_y, ybavg, x1, x2
> real	x, y, weight_1, weight_2
> pointer	yi_blmavgi()
> errchk	yi_blmavgi
> 
> begin
> 	nraw = IM_LEN(SI_IM(si),1)
> 	npix = SI_NPIX(si,1)
> 
> 	# Determine the range of X (in pixels on the block averaged input image)
> 	# required for the interpolator.
> 
> 	gp = SI_GRID(si,1)
> 	x1 = SI_XOFF(si)
> 	x = Memr[gp+npix-1]
> 	x2 = x1 + int(x)
> 	if (INTVAL(x,SI_TOL))
> 	    x2 = x2 - 1
> 	x2 = max (x1 + 1, x2)
> 
> 	gp = SI_GRID(si,2)
> 	y = Memr[gp+lineno-1]
> 
> 	# The following is an optimization provided for the case when it is
> 	# not necessary to interpolate in either X or Y.  Block averaging is
> 	# permitted.
> 
> 	if (SI_INTERP(si,1) == NO && SI_INTERP(si,2) == NO)
> 	    return (yi_blmavgi (SI_IM(si), SI_FP(si), x1, x2, int(y),
> 		SI_BAVG(si,1), SI_BAVG(si,2), SI_ORDER(si)))
> 
> 	# If we are interpolating in Y two buffers are required, one for each
> 	# of the two input image lines required to interpolate in Y.  The lines
> 	# stored in these buffers are interpolated in X to the output grid but
> 	# not in Y.  Both buffers are not required if we are not interpolating
> 	# in Y, but we use them anyhow to simplify the code.
> 
> 	if (SI_INIT(si) == YES) {
> 	    do i = 1, 2 {
> 		if (SI_BUF(si,i) != NULL)
> 		    call mfree (SI_BUF(si,i), SI_TYBUF(si))
> 		call malloc (SI_BUF(si,i), npix, TY_INT)
> 		SI_TYBUF(si) = TY_INT
> 		SI_BUFY(si,i) = NOTSET
> 	    }
> 	    if (OUTBUF(si) != NULL)
> 		call mfree (OUTBUF(si), SI_TYBUF(si))
> 	    call malloc (OUTBUF(si), npix, TY_INT)
> 	    SI_INIT(si) = NO
> 	}
> 
> 	# If the Y value of the new line is not in range of the contents of the
> 	# current line buffers, refill one or both buffers.  To refill we must
> 	# read a (possibly block averaged) input line and interpolate it onto
> 	# the X grid.  The X and Y values herein are in the coordinate system
> 	# of the (possibly block averaged) input image.
> 
> 	new_y[1] = int(y)
> 	new_y[2] = int(y) + 1
> 
> 	# Get the pair of lines whose integral Y values form an interval
> 	# containing the fractional Y value of the output line.  Sometimes the
> 	# desired line will happen to be in the other buffer already, in which
> 	# case we just have to swap buffers.  Often the new line will be the
> 	# current line, in which case nothing is done.  This latter case occurs
> 	# frequently when the magnification ratio is large.
> 
> 	curbuf = 1
> 	altbuf = 2
> 
> 	do i = 1, 2 {
> 	    if (new_y[i] == SI_BUFY(si,i)) {
> 		;
> 	    } else if (new_y[i] == SI_BUFY(si,altbuf)) {
> 		SWAPP (SI_BUF(si,1), SI_BUF(si,2))
> 		SWAPI (SI_BUFY(si,1), SI_BUFY(si,2))
> 
> 	    } else {
> 		# Get line and interpolate onto output grid.  If interpolation
> 		# is not required merely copy data out.  This code is set up
> 		# to always use two buffers; in effect, there is one buffer of
> 		# look ahead, even when Y[i] is integral.  This means that we
> 		# will go out of bounds by one line at the top of the image.
> 		# This is handled by copying the last line.
> 
> 		ybavg = SI_BAVG(si,2)
> 		nblks_y = (IM_LEN (SI_IM(si), 2) + ybavg-1) / ybavg
> 		if (new_y[i] <= nblks_y)
> 		    rawline = yi_blmavgi (SI_IM(si), SI_FP(si), x1, x2,
> 			new_y[i], SI_BAVG(si,1), SI_BAVG(si,2), SI_ORDER(si))
> 
> 		if (SI_INTERP(si,1) == NO) {
> 		    call amovi (Memi[rawline], Memi[SI_BUF(si,i)], npix)
> 		} else if (SI_ORDER(si) == 0) {
> 		    call zi_samplei (Memi[rawline], Memi[SI_BUF(si,i)],
> 			Memr[SI_GRID(si,1)], npix)
> 		} else if (SI_ORDER(si) == -1) {
> 		    call zi_maxi (Memi[rawline], nraw,
> 		    	Memr[SI_GRID(si,1)], Memi[SI_BUF(si,i)], npix)
> 		} else {
> 		    call aluii (Memi[rawline], Memi[SI_BUF(si,i)],
> 			Memr[SI_GRID(si,1)], npix)
> 		}
> 
> 		SI_BUFY(si,i) = new_y[i]
> 	    }
> 
> 	    SWAPI (altbuf, curbuf)
> 	}
> 
> 	# We now have two line buffers straddling the output Y value,
> 	# interpolated to the X grid of the output line.  To complete the
> 	# bilinear interpolation operation we take a weighted sum of the two
> 	# lines.  If the range from SI_BUFY(si,1) to SI_BUFY(si,2) is repeatedly
> 	# interpolated in Y no additional i/o occurs and the linear
> 	# interpolation operation (ALUI) does not have to be repeated (only the
> 	# weighted sum is required).  If the distance of Y from one of the
> 	# buffers is zero then we do not even have to take a weighted sum.
> 	# This is not unusual because we may be called with a magnification
> 	# of 1.0 in Y.
> 
> 	weight_1 = 1.0 - (y - SI_BUFY(si,1))
> 	weight_2 = 1.0 - weight_1
> 
> 	if (weight_1 < SI_TOL)
> 	    return (SI_BUF(si,2))
> 	else if (weight_2 < SI_TOL || SI_ORDER(si) == 0)
> 	    return (SI_BUF(si,1))
> 	else if (SI_ORDER(si) == -1) {
> 	    call amaxi (Memi[SI_BUF(si,1)], Memi[SI_BUF(si,2)],
> 		Memi[OUTBUF(si)], npix)
> 	    return (OUTBUF(si))
> 	} else {
> 	    call awsui (Memi[SI_BUF(si,1)], Memi[SI_BUF(si,2)],
> 		Memi[OUTBUF(si)], npix, weight_1, weight_2)
> 	    return (OUTBUF(si))
> 	}
> end
> 
> 
> # SI_BLMAVGI -- Get a line from a block averaged image of type integer.
> # For example, block averaging by a factor of 2 means that pixels 1 and 2
> # are averaged to produce the first output pixel, 3 and 4 are averaged to
> # produce the second output pixel, and so on.  If the length of an axis
> # is not an integral multiple of the block size then the last pixel in the
> # last block will be replicated to fill out the block; the average is still
> # defined even if a block is not full.
> 
> pointer procedure yi_blmavgi (im, fp, x1, x2, y, xbavg, ybavg, order)
> 
> pointer	im			# input image
> pointer	fp			# fixpix structure
> int	x1, x2			# range of x blocks to be read
> int	y			# y block to be read
> int	xbavg, ybavg		# X and Y block averaging factors
> int	order			# averaging option
> 
> real	sum
> int	blkmax
> pointer	sp, a, b
> int	nblks_x, nblks_y, ncols, nlines, xoff, blk1, blk2, i, j, k
> int	first_line, nlines_in_sum, npix, nfull_blks, count
> pointer	xt_fpi()
> errchk	xt_fpi
> 
> begin
> 	call smark (sp)
> 
> 	ncols  = IM_LEN(im,1)
> 	nlines = IM_LEN(im,2)
> 	xoff   = (x1 - 1) * xbavg + 1
> 	npix   = min (ncols, xoff + (x2 - x1 + 1) * xbavg - 1) - xoff + 1
> 
> 	if ((xbavg < 1) || (ybavg < 1))
> 	    call error (1, "si_blmavg: illegal block size")
> 	else if (x1 < 1 || x2 > ncols)
> 	    call error (2, "si_blmavg: column index out of bounds")
> 	else if ((xbavg == 1) && (ybavg == 1))
> 	    return (xt_fpi (fp, im, y, NULL) + xoff - 1)
> 
> 	nblks_x = (npix   + xbavg-1) / xbavg
> 	nblks_y = (nlines + ybavg-1) / ybavg
> 
> 	if (y < 1 || y > nblks_y)
> 	    call error (2, "si_blmavg: block number out of range")
> 
> 	if (ybavg > 1) {
> 	    call salloc (b, nblks_x, TY_LONG)
> 	    call aclrl (Meml[b], nblks_x)
> 	    nlines_in_sum = 0
> 	}
> 
> 	# Read and accumulate all input lines in the block.
> 	first_line = (y - 1) * ybavg + 1
> 
> 	do i = first_line, min (nlines, first_line + ybavg - 1) {
> 	    # Get line from input image.
> 	    a = xt_fpi (fp, im, i, NULL) + xoff - 1
> 
> 	    # Block average line in X.
> 	    if (xbavg > 1) {
> 		# First block average only the full blocks.
> 		nfull_blks = npix / xbavg
> 		if (order == -1) {
> 		    blk1 = a
> 		    do j = 1, nfull_blks {
> 			blk2 = blk1 + xbavg
> 			blkmax = Memi[blk1]
> 			do k = blk1+1, blk2-1
> 			    blkmax = max (blkmax, Memi[k])
> 			Memi[a+j-1] = blkmax
> 			blk1 = blk2
> 		    }
> 		} else
> 		    call abavi (Memi[a], Memi[a], nfull_blks, xbavg)
> 
> 		# Now average the final partial block, if any.
> 		if (nfull_blks < nblks_x) {
> 		    if (order == -1) {
> 			blkmax = Memi[blk1]
> 			do k = blk1+1, a+npix-1
> 			    blkmax = max (blkmax, Memi[k])
> 			Memi[a+j-1] = blkmax
> 		    } else {
> 			sum = 0.0
> 			count = 0
> 			do j = nfull_blks * xbavg + 1, npix {
> 			    sum = sum + Memi[a+j-1]
> 			    count = count + 1
> 			}
> 			Memi[a+nblks_x-1] = sum / count
> 		    }
> 		}
> 	    }
> 
> 	    # Add line into block sum.  Keep track of number of lines in sum
> 	    # so that we can compute block average later.
> 
> 	    if (ybavg > 1) {
> 		if (order == -1) {
> 		    do j = 0, nblks_x-1
> 			Meml[b+j] = max (Meml[b+j], long (Memi[a+j]))
> 		} else {
> 		    do j = 0, nblks_x-1
> 			Meml[b+j] = Meml[b+j] + Memi[a+j]
> 		    nlines_in_sum = nlines_in_sum + 1
> 		}
> 	    }
> 	}
> 
> 	# Compute the block average in Y from the sum of all lines block
> 	# averaged in X.  Overwrite buffer A, the buffer returned by IMIO.
> 	# This is kosher because the block averaged line is never longer
> 	# than an input line.
> 
> 	if (ybavg > 1) {
> 	    if (order == -1) {
> 		do i = 0, nblks_x-1
> 		    Memi[a+i] = Meml[b+i]
> 	    } else {
> 		do i = 0, nblks_x-1
> 		    Memi[a+i] = Meml[b+i] / real(nlines_in_sum)
> 	    }
> 	}
> 
> 	call sfree (sp)
> 	return (a)
> end
> 
> 
> 
> # SIGM2 -- Get a line of data from a scaled image.  Block averaging is
> # done by a subprocedure; this procedure gets a line from a possibly block
> # averaged image and if necessary interpolates it to the grid points of the
> # output line.
> 
> pointer procedure zigm2s (mg, si, lineno)
> 
> pointer	mg		# pointer to MOSGEOM descriptor
> pointer	si		# pointer to SI descriptor
> int	lineno
> 
> pointer	rawline, tempp, gp
> int	i, new_y[2], tempi, curbuf, altbuf
> int	nraw, npix, nblks_y, ybavg, x1, x2
> real	x, y, weight_1, weight_2
> pointer	zi_blmavgs()
> errchk	zi_blmavgs
> 
> begin
> 	nraw = IM_LEN(SI_IM(si))
> 	npix = SI_NPIX(si,1)
> 
> 	# Determine the range of X (in pixels on the block averaged input image)
> 	# required for the interpolator.
> 
> 	gp = SI_GRID(si,1)
> 	x1 = SI_XOFF(si)
> 	x = Memr[gp+npix-1]
> 	x2 = x1 + int(x)
> 	if (INTVAL(x,SI_TOL))
> 	    x2 = x2 - 1
> 	x2 = max (x1 + 1, x2)
> 
> 	gp = SI_GRID(si,2)
> 	y = Memr[gp+lineno-1]
> 
> 	# The following is an optimization provided for the case when it is
> 	# not necessary to interpolate in either X or Y.  Block averaging is
> 	# permitted.
> 
> 	if (SI_INTERP(si,1) == NO && SI_INTERP(si,2) == NO)
> 	    return (zi_blmavgs (mg, SI_IM(si), SI_FP(si), x1, x2, int(y),
> 		SI_BAVG(si,1), SI_BAVG(si,2), SI_ORDER(si)))
> 
> 	# If we are interpolating in Y two buffers are required, one for each
> 	# of the two input image lines required to interpolate in Y.  The lines
> 	# stored in these buffers are interpolated in X to the output grid but
> 	# not in Y.  Both buffers are not required if we are not interpolating
> 	# in Y, but we use them anyhow to simplify the code.
> 
> 	if (SI_INIT(si) == YES) {
> 	    do i = 1, 2 {
> 		if (SI_BUF(si,i) != NULL)
> 		    call mfree (SI_BUF(si,i), SI_TYBUF(si))
> 		call malloc (SI_BUF(si,i), npix, TY_SHORT)
> 		SI_TYBUF(si) = TY_SHORT
> 		SI_BUFY(si,i) = NOTSET
> 	    }
> 	    if (OUTBUF(si) != NULL)
> 		call mfree (OUTBUF(si), SI_TYBUF(si))
> 	    call malloc (OUTBUF(si), npix, TY_SHORT)
> 	    SI_INIT(si) = NO
> 	}
> 
> 	# If the Y value of the new line is not in range of the contents of the
> 	# current line buffers, refill one or both buffers.  To refill we must
> 	# read a (possibly block averaged) input line and interpolate it onto
> 	# the X grid.  The X and Y values herein are in the coordinate system
> 	# of the (possibly block averaged) input image.
> 
> 	new_y[1] = int(y)
> 	new_y[2] = int(y) + 1
> 
> 	# Get the pair of lines whose integral Y values form an interval
> 	# containing the fractional Y value of the output line.  Sometimes the
> 	# desired line will happen to be in the other buffer already, in which
> 	# case we just have to swap buffers.  Often the new line will be the
> 	# current line, in which case nothing is done.  This latter case occurs
> 	# frequently when the magnification ratio is large.
> 
> 	curbuf = 1
> 	altbuf = 2
> 
> 	do i = 1, 2 {
> 	    if (new_y[i] == SI_BUFY(si,i)) {
> 		;
> 	    } else if (new_y[i] == SI_BUFY(si,altbuf)) {
> 		SWAPP (SI_BUF(si,1), SI_BUF(si,2))
> 		SWAPI (SI_BUFY(si,1), SI_BUFY(si,2))
> 
> 	    } else {
> 		# Get line and interpolate onto output grid.  If interpolation
> 		# is not required merely copy data out.  This code is set up
> 		# to always use two buffers; in effect, there is one buffer of
> 		# look ahead, even when Y[i] is integral.  This means that we
> 		# will go out of bounds by one line at the top of the image.
> 		# This is handled by copying the last line.
> 
> 		ybavg = SI_BAVG(si,2)
> 		nblks_y = (IM_LEN (SI_IM(si), 2) + ybavg-1) / ybavg
> 		if (new_y[i] <= nblks_y)
> 		    rawline = zi_blmavgs (mg, SI_IM(si), SI_FP(si), x1, x2,
> 			new_y[i], SI_BAVG(si,1), SI_BAVG(si,2), SI_ORDER(si))
> 
> 		if (SI_INTERP(si,1) == NO) {
> 		    call amovs (Mems[rawline], Mems[SI_BUF(si,i)], npix)
> 		} else if (SI_ORDER(si) == 0) {
> 		    call zi_samples (Mems[rawline], Mems[SI_BUF(si,i)],
> 			Memr[SI_GRID(si,1)], npix)
> 		} else if (SI_ORDER(si) == -1) {
> 		    call zi_maxs (Mems[rawline], nraw,
> 			Memr[SI_GRID(si,1)], Mems[SI_BUF(si,i)], npix)
> 		} else {
> 		    call aluis (Mems[rawline], Mems[SI_BUF(si,i)],
> 			Memr[SI_GRID(si,1)], npix)
> 		}
> 
> 		SI_BUFY(si,i) = new_y[i]
> 	    }
> 
> 	    SWAPI (altbuf, curbuf)
> 	}
> 
> 	# We now have two line buffers straddling the output Y value,
> 	# interpolated to the X grid of the output line.  To complete the
> 	# bilinear interpolation operation we take a weighted sum of the two
> 	# lines.  If the range from SI_BUFY(si,1) to SI_BUFY(si,2) is repeatedly
> 	# interpolated in Y no additional i/o occurs and the linear
> 	# interpolation operation (ALUI) does not have to be repeated (only the
> 	# weighted sum is required).  If the distance of Y from one of the
> 	# buffers is zero then we do not even have to take a weighted sum.
> 	# This is not unusual because we may be called with a magnification
> 	# of 1.0 in Y.
> 
> 	weight_1 = 1.0 - (y - SI_BUFY(si,1))
> 	weight_2 = 1.0 - weight_1
> 
> 	if (weight_1 < SI_TOL)
> 	    return (SI_BUF(si,2))
> 	else if (weight_2 < SI_TOL || SI_ORDER(si) == 0) 
> 	    return (SI_BUF(si,1))
> 	else if (SI_ORDER(si) == -1) {
> 	    call amaxs (Mems[SI_BUF(si,1)], Mems[SI_BUF(si,2)],
> 		Mems[OUTBUF(si)], npix)
> 	    return (OUTBUF(si))
> 	} else {
> 	    call awsus (Mems[SI_BUF(si,1)], Mems[SI_BUF(si,2)],
> 		Mems[OUTBUF(si)], npix, weight_1, weight_2)
> 	    return (OUTBUF(si))
> 	}
> end
> 
> 
> # SI_BLMAVG -- Get a line from a block averaged image of type short.
> # For example, block averaging by a factor of 2 means that pixels 1 and 2
> # are averaged to produce the first output pixel, 3 and 4 are averaged to
> # produce the second output pixel, and so on.  If the length of an axis
> # is not an integral multiple of the block size then the last pixel in the
> # last block will be replicated to fill out the block; the average is still
> # defined even if a block is not full.
> 
> pointer procedure zi_blmavgs (mg, im, fp, x1, x2, y, xbavg, ybavg, order)
> 
> pointer	mg			# mosgeom descriptor
> pointer	im			# input image
> pointer	fp			# fixpix structure
> int	x1, x2			# range of x blocks to be read
> int	y			# y block to be read
> int	xbavg, ybavg		# X and Y block averaging factors
> int	order			# averaging option
> 
> real	sum
> short	blkmax
> pointer	sp, a, b
> int	nblks_x, nblks_y, ncols, nlines, xoff, blk1, blk2, i, j, k
> int	first_line, nlines_in_sum, npix, nfull_blks, count
> pointer	zt_fps()
> errchk	zt_fps
> 
> begin
> 	call smark (sp)
> 
> 	ncols  = IM_LEN(im,1)
> 	nlines = IM_LEN(im,2)
> 	xoff   = (x1 - 1) * xbavg + 1
> 	npix   = min (ncols, xoff + (x2 - x1 + 1) * xbavg - 1) - xoff + 1
> 
> 	if ((xbavg < 1) || (ybavg < 1))
> 	    call error (1, "zi_blmavg: illegal block size")
> 	else if (x1 < 1 || x2 > ncols)
> 	    call error (2, "zi_blmavg: column index out of bounds")
> 	else if ((xbavg == 1) && (ybavg == 1))
> 	    return (zt_fps (fp, mg, y, NULL) + xoff - 1)
> 
> 	nblks_x = (npix   + xbavg-1) / xbavg
> 	nblks_y = (nlines + ybavg-1) / ybavg
> 
> 	if (y < 1 || y > nblks_y)
> 	    call error (2, "zi_blmavg: block number out of range")
> 
> 	if (ybavg > 1) {
> 	    call salloc (b, nblks_x, TY_LONG)
> 	    call aclrl (Meml[b], nblks_x)
> 	    nlines_in_sum = 0
> 	}
> 
> 	# Read and accumulate all input lines in the block.
> 	first_line = (y - 1) * ybavg + 1
> 
> 	do i = first_line, min (nlines, first_line + ybavg - 1) {
> 	    # Get line from input image.
> 	    a = zt_fps (fp, mg, i, NULL) + xoff - 1
> 
> 	    # Block average line in X.
> 	    if (xbavg > 1) {
> 		# First block average only the full blocks.
> 		nfull_blks = npix / xbavg
> 		if (order == -1) {
> 		    blk1 = a
> 		    do j = 1, nfull_blks {
> 			blk2 = blk1 + xbavg
> 			blkmax = Mems[blk1]
> 			do k = blk1+1, blk2-1
> 			    blkmax = max (blkmax, Mems[k])
> 			Mems[a+j-1] = blkmax
> 			blk1 = blk2
> 		    }
> 		} else
> 		    call abavs (Mems[a], Mems[a], nfull_blks, xbavg)
> 
> 		# Now average the final partial block, if any.
> 		if (nfull_blks < nblks_x) {
> 		    if (order == -1) {
> 			blkmax = Mems[blk1]
> 			do k = blk1+1, a+npix-1
> 			    blkmax = max (blkmax, Mems[k])
> 			Mems[a+j-1] = blkmax
> 		    } else {
> 			sum = 0.0
> 			count = 0
> 			do j = nfull_blks * xbavg + 1, npix {
> 			    sum = sum + Mems[a+j-1]
> 			    count = count + 1
> 			}
> 			Mems[a+nblks_x-1] = sum / count
> 		    }
> 		}
> 	    }
> 
> 	    # Add line into block sum.  Keep track of number of lines in sum
> 	    # so that we can compute block average later.
> 
> 	    if (ybavg > 1) {
> 		if (order == -1) {
> 		    do j = 0, nblks_x-1
> 			Meml[b+j] = max (Meml[b+j], long (Mems[a+j]))
> 		} else {
> 		    do j = 0, nblks_x-1
> 			Meml[b+j] = Meml[b+j] + Mems[a+j]
> 		    nlines_in_sum = nlines_in_sum + 1
> 		}
> 	    }
> 	}
> 
> 	# Compute the block average in Y from the sum of all lines block
> 	# averaged in X.  Overwrite buffer A, the buffer returned by IMIO.
> 	# This is kosher because the block averaged line is never longer
> 	# than an input line.
> 
> 	if (ybavg > 1) {
> 	    if (order == -1) {
> 		do i = 0, nblks_x-1
> 		    Mems[a+i] = Meml[b+i]
> 	    } else {
> 		do i = 0, nblks_x-1
> 		    Mems[a+i] = Meml[b+i] / real(nlines_in_sum)
> 	    }
> 	}
> 
> 	call sfree (sp)
> 	return (a)
> end
> 
> 
> # SI_MAXS -- Resample a line via maximum value.
> 
> procedure zi_maxs (a, na, x, b, nb)
> 
> short	a[na]			# input array
> int	na			# input size
> real	x[nb]			# sample grid
> short	b[nb]			# output arrays
> int	nb			# output size
> 
> int	i
> 
> begin
> 	do i = 1, nb
> 	    b[i] = max (a[int(x[i])], a[min(na,int(x[i]+1))])
> end
> 
> 
> # XT_FP -- Get the specified line of image data and replace bad pixels by
> # interpolation.
> 
> pointer procedure zt_fps (fp, mg, line, fd)
> 
> pointer	fp			#I FIXPIX pointer
> pointer	mg			#I MOSGEOM pointer
> int	line			#I Line
> int	fd			#I File descriptor for pixel list
> 
> int	col1, col2		#I Section of interest
> int	line1, line2		#I Section of interest
> 
> pointer	im, mscl2s(), zt_fpss()
> 
> begin
> 	# If there are no bad pixels just get the image line and return.
> 	if (fp == NULL)
> 	    return (mscl2s (mg, line))
> 
> 	im = MG_IM(mg)
> 	col1 = 1
> 	col2 = IM_LEN(im,1)
> 	line1 = 1
> 	line2 = IM_LEN(im,2)
> 
> 	return (zt_fpss (fp, mg, line, col1, col2, line1, line2, fd))
> end
> 
> 
> # XT_FXS -- Get the specified line of image data and replace bad pixels by
> # interpolation within a specified section.
> 
> pointer procedure zt_fpss (fp, mg, line, col1, col2, line1, line2, fd)
> 
> pointer	fp			#I FIXPIX pointer
> pointer	mg			#I MOSGEOM pointer
> int	line			#I Line
> int	fd			#I File descriptor for pixel list
> 
> int	col1, col2		#I Section of interest
> int	line1, line2		#I Section of interest
> 
> int	i, j, nc, nl, ncols, c1, c2, l1, l2, l3, l4
> long	v[IM_MAXDIM]
> real	a, b, c, d, val
> short	indef
> pointer	im, pm, data, bp
> 
> bool	pm_linenotempty()
> pointer	mscl2s(), zt_fpvals()
> 
> begin
> 	# If there are no bad pixels just get the image line and return.
> 	if (fp == NULL)
> 	    return (mscl2s (mg, line))
> 
> 	# Initialize
> 	im = MG_IM(mg)
> 	pm = FP_PM(fp)
> 	nc = IM_LEN(im,1)
> 	nl = IM_LEN(im,2)
> 	ncols = FP_NCOLS(fp)
> 	call amovkl (long(1), v, IM_MAXDIM)
> 	v[2] = line
> 
> 	# If there might be column interpolation initialize value arrays.
> 	if (ncols > 0 && FP_PV1(fp) == NULL) {
> 	    FP_PIXTYPE(fp) = TY_SHORT
> 	    call malloc (FP_PV1(fp), ncols, FP_PIXTYPE(fp))
> 	    call malloc (FP_PV2(fp), ncols, FP_PIXTYPE(fp))
> 	    indef = INDEFS
> 	    call amovks (indef, Mems[FP_V1(fp,1)], ncols)
> 	    call amovks (indef, Mems[FP_V2(fp,1)], ncols)
> 	}
> 
> 	# If there are no bad pixels in the line and the line contains
> 	# no column interpolation endpoints return the data directly.
> 	# Otherwise get the line and fill in any endpoints that may
> 	# be used later.
> 
> 	if (!pm_linenotempty (pm, v)) {
> 	    if (line < FP_LMIN(fp) || line > FP_LMAX(fp))
> 		return (mscl2s (mg, line))
> 	    else
> 		return (zt_fpvals (fp, mg, line))
> 	}
> 
> 	# Get the pixel mask.
> 	call malloc (bp, nc, TY_SHORT)
> 	call pmglps (pm, v, Mems[bp], 0, nc, PIX_SRC)
> 	bp = bp - 1
> 
> 	# Check if any column interpolation endpoints are needed and
> 	# set them.  Set any other endpoints on the same lines at
> 	# the same time.
> 
> 	if (line >= FP_LMIN(fp) && line < FP_LMAX(fp)) {
> 	    j = 1
> 	    do i = col1, col2 {
> 		if (Mems[bp+i] == FP_CVAL(fp)) {
> 		    for (; j<=ncols && FP_COL(fp,j)!=i; j=j+1)
> 			;
> 		    for (; j<=ncols && FP_COL(fp,j)==i; j=j+1) {
> 			if (line>FP_L1(fp,j) && line<FP_L2(fp,j)) {
> 			    if (IS_INDEFS(Mems[FP_V1(fp,j)]))
> 				data = zt_fpvals (fp, im, FP_L1(fp,j))
> 			    if (IS_INDEFS(Mems[FP_V2(fp,j)]))
> 				data = zt_fpvals (fp, im, FP_L2(fp,j))
> 			}
> 		    }
> 		}
> 	    }
> 	}
> 
> 	# Fix pixels by column or line interpolation.
> 	if (FP_DATA(fp) == NULL) {
> 	    FP_PIXTYPE(fp) = TY_SHORT
> 	    call malloc (FP_DATA(fp), nc, FP_PIXTYPE(fp))
> 	}
> 	data = FP_DATA(fp)
> 	call amovs (Mems[zt_fpvals(fp,im,line)], Mems[data], nc)
> 	j = 1
> 	for (c1=col1; c1<=col2 && Mems[bp+c1]==0; c1=c1+1)
> 	    ;
> 	while (c1 <= col2) {
> 	    c1 = c1 - 1
> 	    for (c2=c1+2; c2<=col2 && Mems[bp+c2]!=0; c2=c2+1)
> 		;
> 	    a = INDEFS
> 	    do i = c1+1, c2-1 {
> 		if (Mems[bp+i] == FP_LVAL(fp)) {
> 		    if (IS_INDEFS(a)) {
> 			if (c1 < col1 && c2 > col2) {
> 			    c1 = c2 + 1
> 			    next
> 			}
> 			if (c1 >= col1)
> 			    a = Mems[data+c1-1]
> 			else
> 			    a = Mems[data+c2-1]
> 			if (c2 <= col2)
> 			    b = (Mems[data+c2-1] - a) / (c2 - c1)
> 			else
> 			    b = 0.
> 		    }
> 		    val = a + b * (i - c1)
> 		    if (fd != NULL) {
> 			call fprintf (fd, "%4d %4d %8g %8g")
> 			    call pargi (i)
> 			    call pargi (line)
> 			    call pargs (Mems[data+i-1])
> 			    call pargr (val)
> 			if (c1 >= col1) {
> 			    call fprintf (fd, "%4d %4d")
> 			    call pargi (c1)
> 			    call pargi (line)
> 			}
> 			if (c2 <= col2) {
> 			    call fprintf (fd, "%4d %4d")
> 			    call pargi (c2)
> 			    call pargi (line)
> 			}
> 			call fprintf (fd, "\n")
> 		    }
> 		} else {
> 		    for (; j<ncols && FP_COL(fp,j)!=i; j=j+1)
> 			;
> 		    for (; j<ncols && FP_COL(fp,j)==i; j=j+1) {
> 			l1 = FP_L1(fp,j)
> 			l2 = FP_L2(fp,j)
> 			if (l1 < line1 && l2 > line2)
> 			    next
> 			if (line > l1 && line < l2) {
> 			    if (l1 >= line1)
> 				c = Mems[FP_V1(fp,j)]
> 			    else
> 				c = Mems[FP_V2(fp,j)]
> 			    if (l2 <= line2) {
> 				d = (Mems[FP_V2(fp,j)] - c) / (l2 - l1)
> 				val = c + d * (line - l1)
> 			    } else
> 				val = c
> 			    l3 = l1
> 			    l4 = l2
> 			}
> 		    }
> 		    if (fd != NULL) {
> 			call fprintf (fd, "%4d %4d %8g %8g")
> 			    call pargi (i)
> 			    call pargi (line)
> 			    call pargs (Mems[data+i-1])
> 			    call pargr (val)
> 			if (l1 >= line1) {
> 			    call fprintf (fd, "%4d %4d")
> 			    call pargi (i)
> 			    call pargi (l3)
> 			}
> 			if (l2 <= line2) {
> 			    call fprintf (fd, "%4d %4d")
> 			    call pargi (i)
> 			    call pargi (l4)
> 			}
> 			call fprintf (fd, "\n")
> 		    }
> 		}
> 		Mems[data+i-1] = nint (val)
> 	    }
> 	    for (c1=c2+1; c1<=col2 && Mems[bp+c1]==0; c1=c1+1)
> 		;
> 	}
> 
> 	call mfree (bp, TY_SHORT)
> 	return (data)
> end
> 
> 
> # XT_FPVAL -- Get data for the specified line and set the values for
> # all column interpolation endpoints which occur at that line.
> 
> pointer procedure zt_fpvals (fp, mg, line)
> 
> pointer	fp			#I FIXPIX pointer
> pointer	mg			#I MOSGEOM pointer
> int	line			#I Line
> 
> int	i
> pointer	im, data, mscl2s()
> 
> begin
> 	# Set out of bounds values to 0.  These are not used but we need
> 	# to cancel the INDEF values.
> 	im = MG_IM(mg)
> 	if (line < 1 || line > IM_LEN(im,2)) {
> 	    do i = 1, FP_NCOLS(fp) {
> 		if (line == FP_L1(fp,i))
> 		    Mems[FP_V1(fp,i)] = 0.
> 		else if (line == FP_L2(fp,i))
> 		    Mems[FP_V2(fp,i)] = 0.
> 	    }
> 	    return (NULL)
> 	}
> 
> 	data = mscl2s (mg, line)
> 	do i = 1, FP_NCOLS(fp) {
> 	    if (line == FP_L1(fp,i))
> 		Mems[FP_V1(fp,i)] = Mems[data+FP_COL(fp,i)-1]
> 	    else if (line == FP_L2(fp,i))
> 		Mems[FP_V2(fp,i)] = Mems[data+FP_COL(fp,i)-1]
> 	}
> 
> 	return (data)
> end
> 
> # SI_SAMPLE -- Resample a line via nearest neighbor, rather than linear
> # interpolation (ALUI).  The calling sequence is the same as for ALUII.
> 
> procedure zi_samples (a, b, x, npix)
> 
> short	a[ARB], b[ARB]		# input, output data arrays
> real	x[ARB]			# sample grid
> int	npix, i
> 
> begin
> 	do i = 1, npix
> 	    b[i] = a[int(x[i])]
> end
> 
> 
332c1186
< pointer procedure zigm2s (mg, si, lineno)
---
> pointer procedure zigm2i (mg, si, lineno)
342,343c1196,1197
< pointer	zi_blmavgs()
< errchk	zi_blmavgs
---
> pointer	zi_blmavgi()
> errchk	zi_blmavgi
368c1222
< 	    return (zi_blmavgs (mg, SI_IM(si), SI_FP(si), x1, x2, int(y),
---
> 	    return (zi_blmavgi (mg, SI_IM(si), SI_FP(si), x1, x2, int(y),
381,382c1235,1236
< 		call malloc (SI_BUF(si,i), npix, TY_SHORT)
< 		SI_TYBUF(si) = TY_SHORT
---
> 		call malloc (SI_BUF(si,i), npix, TY_INT)
> 		SI_TYBUF(si) = TY_INT
387c1241
< 	    call malloc (OUTBUF(si), npix, TY_SHORT)
---
> 	    call malloc (OUTBUF(si), npix, TY_INT)
428c1282
< 		    rawline = zi_blmavgs (mg, SI_IM(si), SI_FP(si), x1, x2,
---
> 		    rawline = zi_blmavgi (mg, SI_IM(si), SI_FP(si), x1, x2,
432c1286
< 		    call amovs (Mems[rawline], Mems[SI_BUF(si,i)], npix)
---
> 		    call amovi (Memi[rawline], Memi[SI_BUF(si,i)], npix)
434c1288
< 		    call si_samples (Mems[rawline], Mems[SI_BUF(si,i)],
---
> 		    call zi_samplei (Memi[rawline], Memi[SI_BUF(si,i)],
437,438c1291,1292
< 		    call zi_maxs (Mems[rawline], nraw,
< 			Memr[SI_GRID(si,1)], Mems[SI_BUF(si,i)], npix)
---
> 		    call zi_maxi (Memi[rawline], nraw,
> 			Memr[SI_GRID(si,1)], Memi[SI_BUF(si,i)], npix)
440c1294
< 		    call aluis (Mems[rawline], Mems[SI_BUF(si,i)],
---
> 		    call aluii (Memi[rawline], Memi[SI_BUF(si,i)],
469,470c1323,1324
< 	    call amaxs (Mems[SI_BUF(si,1)], Mems[SI_BUF(si,2)],
< 		Mems[OUTBUF(si)], npix)
---
> 	    call amaxi (Memi[SI_BUF(si,1)], Memi[SI_BUF(si,2)],
> 		Memi[OUTBUF(si)], npix)
473,474c1327,1328
< 	    call awsus (Mems[SI_BUF(si,1)], Mems[SI_BUF(si,2)],
< 		Mems[OUTBUF(si)], npix, weight_1, weight_2)
---
> 	    call awsui (Memi[SI_BUF(si,1)], Memi[SI_BUF(si,2)],
> 		Memi[OUTBUF(si)], npix, weight_1, weight_2)
488c1342
< pointer procedure zi_blmavgs (mg, im, fp, x1, x2, y, xbavg, ybavg, order)
---
> pointer procedure zi_blmavgi (mg, im, fp, x1, x2, y, xbavg, ybavg, order)
499c1353
< short	blkmax
---
> int	blkmax
503,504c1357,1358
< pointer	zt_fps()
< errchk	zt_fps
---
> pointer	zt_fpi()
> errchk	zt_fpi
519c1373
< 	    return (zt_fps (fp, mg, y, NULL) + xoff - 1)
---
> 	    return (zt_fpi (fp, mg, y, NULL) + xoff - 1)
538c1392
< 	    a = zt_fps (fp, mg, i, NULL) + xoff - 1
---
> 	    a = zt_fpi (fp, mg, i, NULL) + xoff - 1
548c1402
< 			blkmax = Mems[blk1]
---
> 			blkmax = Memi[blk1]
550,551c1404,1405
< 			    blkmax = max (blkmax, Mems[k])
< 			Mems[a+j-1] = blkmax
---
> 			    blkmax = max (blkmax, Memi[k])
> 			Memi[a+j-1] = blkmax
555c1409
< 		    call abavs (Mems[a], Mems[a], nfull_blks, xbavg)
---
> 		    call abavi (Memi[a], Memi[a], nfull_blks, xbavg)
560c1414
< 			blkmax = Mems[blk1]
---
> 			blkmax = Memi[blk1]
562,563c1416,1417
< 			    blkmax = max (blkmax, Mems[k])
< 			Mems[a+j-1] = blkmax
---
> 			    blkmax = max (blkmax, Memi[k])
> 			Memi[a+j-1] = blkmax
568c1422
< 			    sum = sum + Mems[a+j-1]
---
> 			    sum = sum + Memi[a+j-1]
571c1425
< 			Mems[a+nblks_x-1] = sum / count
---
> 			Memi[a+nblks_x-1] = sum / count
582c1436
< 			Meml[b+j] = max (Meml[b+j], long (Mems[a+j]))
---
> 			Meml[b+j] = max (Meml[b+j], long (Memi[a+j]))
585c1439
< 			Meml[b+j] = Meml[b+j] + Mems[a+j]
---
> 			Meml[b+j] = Meml[b+j] + Memi[a+j]
599c1453
< 		    Mems[a+i] = Meml[b+i]
---
> 		    Memi[a+i] = Meml[b+i]
602c1456
< 		    Mems[a+i] = Meml[b+i] / real(nlines_in_sum)
---
> 		    Memi[a+i] = Meml[b+i] / real(nlines_in_sum)
613c1467
< procedure zi_maxs (a, na, x, b, nb)
---
> procedure zi_maxi (a, na, x, b, nb)
615c1469
< short	a[na]			# input array
---
> int	a[na]			# input array
618c1472
< short	b[nb]			# output arrays
---
> int	b[nb]			# output arrays
632c1486
< pointer procedure zt_fps (fp, mg, line, fd)
---
> pointer procedure zt_fpi (fp, mg, line, fd)
642c1496
< pointer	im, mscl2s(), zt_fpss()
---
> pointer	im, mscl2i(), zt_fpsi()
647c1501
< 	    return (mscl2s (mg, line))
---
> 	    return (mscl2i (mg, line))
655c1509
< 	return (zt_fpss (fp, mg, line, col1, col2, line1, line2, fd))
---
> 	return (zt_fpsi (fp, mg, line, col1, col2, line1, line2, fd))
662c1516
< pointer procedure zt_fpss (fp, mg, line, col1, col2, line1, line2, fd)
---
> pointer procedure zt_fpsi (fp, mg, line, col1, col2, line1, line2, fd)
675c1529
< short	indef
---
> int	indef
679c1533
< pointer	mscl2s(), zt_fpvals()
---
> pointer	mscl2i(), zt_fpvali()
684c1538
< 	    return (mscl2s (mg, line))
---
> 	    return (mscl2i (mg, line))
697c1551
< 	    FP_PIXTYPE(fp) = TY_SHORT
---
> 	    FP_PIXTYPE(fp) = TY_INT
700,702c1554,1556
< 	    indef = INDEFS
< 	    call amovks (indef, Mems[FP_V1(fp,1)], ncols)
< 	    call amovks (indef, Mems[FP_V2(fp,1)], ncols)
---
> 	    indef = INDEFI
> 	    call amovki (indef, Memi[FP_V1(fp,1)], ncols)
> 	    call amovki (indef, Memi[FP_V2(fp,1)], ncols)
712c1566
< 		return (mscl2s (mg, line))
---
> 		return (mscl2i (mg, line))
714c1568
< 		return (zt_fpvals (fp, mg, line))
---
> 		return (zt_fpvali (fp, mg, line))
734,737c1588,1591
< 			    if (IS_INDEFS(Mems[FP_V1(fp,j)]))
< 				data = zt_fpvals (fp, im, FP_L1(fp,j))
< 			    if (IS_INDEFS(Mems[FP_V2(fp,j)]))
< 				data = zt_fpvals (fp, im, FP_L2(fp,j))
---
> 			    if (IS_INDEFI(Memi[FP_V1(fp,j)]))
> 				data = zt_fpvali (fp, im, FP_L1(fp,j))
> 			    if (IS_INDEFI(Memi[FP_V2(fp,j)]))
> 				data = zt_fpvali (fp, im, FP_L2(fp,j))
746c1600
< 	    FP_PIXTYPE(fp) = TY_SHORT
---
> 	    FP_PIXTYPE(fp) = TY_INT
750c1604
< 	call amovs (Mems[zt_fpvals(fp,im,line)], Mems[data], nc)
---
> 	call amovi (Memi[zt_fpvali(fp,im,line)], Memi[data], nc)
758c1612
< 	    a = INDEFS
---
> 	    a = INDEFI
761c1615
< 		    if (IS_INDEFS(a)) {
---
> 		    if (IS_INDEFI(a)) {
767c1621
< 			    a = Mems[data+c1-1]
---
> 			    a = Memi[data+c1-1]
769c1623
< 			    a = Mems[data+c2-1]
---
> 			    a = Memi[data+c2-1]
771c1625
< 			    b = (Mems[data+c2-1] - a) / (c2 - c1)
---
> 			    b = (Memi[data+c2-1] - a) / (c2 - c1)
780c1634
< 			    call pargs (Mems[data+i-1])
---
> 			    call pargi (Memi[data+i-1])
804c1658
< 				c = Mems[FP_V1(fp,j)]
---
> 				c = Memi[FP_V1(fp,j)]
806c1660
< 				c = Mems[FP_V2(fp,j)]
---
> 				c = Memi[FP_V2(fp,j)]
808c1662
< 				d = (Mems[FP_V2(fp,j)] - c) / (l2 - l1)
---
> 				d = (Memi[FP_V2(fp,j)] - c) / (l2 - l1)
820c1674
< 			    call pargs (Mems[data+i-1])
---
> 			    call pargi (Memi[data+i-1])
835c1689
< 		Mems[data+i-1] = nint (val)
---
> 		Memi[data+i-1] = nint (val)
849c1703
< pointer procedure zt_fpvals (fp, mg, line)
---
> pointer procedure zt_fpvali (fp, mg, line)
856c1710
< pointer	im, data, mscl2s()
---
> pointer	im, data, mscl2i()
865c1719
< 		    Mems[FP_V1(fp,i)] = 0.
---
> 		    Memi[FP_V1(fp,i)] = 0.
867c1721
< 		    Mems[FP_V2(fp,i)] = 0.
---
> 		    Memi[FP_V2(fp,i)] = 0.
872c1726
< 	data = mscl2s (mg, line)
---
> 	data = mscl2i (mg, line)
875c1729
< 		Mems[FP_V1(fp,i)] = Mems[data+FP_COL(fp,i)-1]
---
> 		Memi[FP_V1(fp,i)] = Memi[data+FP_COL(fp,i)-1]
877c1731
< 		Mems[FP_V2(fp,i)] = Mems[data+FP_COL(fp,i)-1]
---
> 		Memi[FP_V2(fp,i)] = Memi[data+FP_COL(fp,i)-1]
882a1737,1750
> # SI_SAMPLE -- Resample a line via nearest neighbor, rather than linear
> # interpolation (ALUI).  The calling sequence is the same as for ALUII.
> 
> procedure zi_samplei (a, b, x, npix)
> 
> int	a[ARB], b[ARB]		# input, output data arrays
> real	x[ARB]			# sample grid
> int	npix, i
> 
> begin
> 	do i = 1, npix
> 	    b[i] = a[int(x[i])]
> end
> 
940a1809,1811
> 		call mfree (SI_BUF(si,i), SI_TYBUF(si))
> 		call malloc (SI_BUF(si,i), npix, TY_REAL)
> 		SI_TYBUF(si) = TY_REAL
992c1863
< 		    call si_sampler (Memr[rawline], Memr[SI_BUF(si,i)],
---
> 		    call zi_sampler (Memr[rawline], Memr[SI_BUF(si,i)],
1434a2306,2319
> # SI_SAMPLE -- Resample a line via nearest neighbor, rather than linear
> # interpolation (ALUI).  The calling sequence is the same as for ALUII.
> 
> procedure zi_sampler (a, b, x, npix)
> 
> real	a[ARB], b[ARB]		# input, output data arrays
> real	x[ARB]			# sample grid
> int	npix, i
> 
> begin
> 	do i = 1, npix
> 	    b[i] = a[int(x[i])]
> end
> 
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/starfocus/mkpkg ./src/starfocus/mkpkg
3,5c3,6
< update:
< 	$call	lsf
< 	;
---
> #$checkout libpkg.a ..
> #$update   libpkg.a
> #$checkin  libpkg.a ..
> #$exit
7,10c8,9
< lsf:
< 	$checkout libsf.a mscbin$
< 	$update   libsf.a
< 	$checkin  libsf.a mscbin$
---
> update:
> 	$update	libpkg.a
13c12
< libsf.a:
---
> libpkg.a:
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/starfocus/mscfocus.cl ./src/starfocus/mscfocus.cl
22c22,23
< 	string	ims
---
> 	string	ims, im, gap
> 	struct	instrum
25a27,33
> 	sections (ims) | scan (im)
> 	hselect (im//"[0]", "$instrume", yes) | scan (instrum)
> 	if (instrum == "Mosaic1.1")
> 	    gap = "end"
> 	else
> 	    gap = "beginning"
> 
31c39,41
< 	mscstarfocus (ims, focus="FOCSTART", fstep="FOCSTEP",
---
> 	set erract = "notrace"
> 	iferr {
> 	    mscstarfocus (ims, focus="FOCSTART", fstep="FOCSTEP",
33c43
< 	    gap="beginning", coords="markall", display=yes, frame=frame,
---
> 	    gap=gap, coords="markall", display=yes, frame=frame,
37a48
> 	} print ($errmsg)
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/starfocus/t_starfocus.x ./src/starfocus/t_starfocus.x
76c76,77
<         call clgstr ("instrument",  Memc[image],  SZ_LINE)
---
>         #call clgstr ("instrument",  Memc[image],  SZ_LINE)
> 	Memc[image] = EOS
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/t_mscdisplay.x ./src/t_mscdisplay.x
32c32
< pointer sp, image, image1, title, wcs
---
> pointer sp, image, image1, title, procstr, wcs
35,36c35,36
< bool    clgetb(), fp_equalr(), streq(), ccdflag()
< int     clgeti(), clgwrd(), btoi(), access(), imd_wcsver()
---
> bool    clgetb(), fp_equalr(), streq(), hdmflag()
> int     clgeti(), clgwrd(), btoi(), access(), imd_wcsver(), imtlen(), imtgetim()
38,39c38,39
< pointer mimap(), imd_mapframe1(), iw_open(), imps2s()
< errchk	imps2s
---
> pointer mimap(), imd_mapframe1(), iw_open(), imps2s(), imtopenp()
> errchk	imps2s, msc_load_display
47a48
>         call salloc (procstr, SZ_LINE, TY_CHAR)
51,52c52,55
<         bufsize = max (1024., 1000000. * clgetr ("im_bufsize"))
<         call clgstr ("instrument",  Memc[image1],  SZ_LINE)
---
>         #bufsize = max (1024., 1000000. * clgetr ("im_bufsize"))
>         bufsize = 65000.
>         #call clgstr ("instrument",  Memc[image1],  SZ_LINE)
> 	Memc[image1] = EOS
60c63,69
<         call clgstr ("image", Memc[image], SZ_LINE)
---
> 	# Get image.
> 	im = imtopenp ("image")
> 	if (imtlen (im) != 1)
> 	    call error (1, "Only one image may be displayed")
> 	i = imtgetim (im, Memc[image], SZ_LINE)
> 	call imtclose (im)
> 
167c176
< 		    if (!ccdflag (im, "flatcor")) {
---
> 		    if (!hdmflag (im, "flatcor")) {
264,267c273,274
< 	    if (k > ninput) {
< 		tx = tx + CX1(cmg) - 1
< 		ty = ty + CY1(cmg) - 1
< 	    }
---
> 	    tx = tx + CX1(cmg) - 1
> 	    ty = ty + CY1(cmg) - 1
272,281c279,295
< 		if (DOBIAS(mg) == YES && DOFLAT(mg) == YES) {
< 		    call sprintf (Memc[title], SZ_LINE, "[bias,flat=%s] %s")
< 			call pargstr (FLATNAME(mg))
< 			call pargstr (IM_TITLE(MI_IM(mi,j)))
< 		} else if (DOBIAS(mg) == YES) {
< 		    call sprintf (Memc[title], SZ_LINE, "[bias] %s")
< 			call pargstr (IM_TITLE(MI_IM(mi,j)))
< 		} else if (DOFLAT(mg) == YES) {
< 		    call sprintf (Memc[title], SZ_LINE, "[flat=%s] %s")
< 			call pargstr (FLATNAME(mg))
---
> 		if (DOBIAS(mg)==YES || DOZERO(mg)==YES || DOFLAT(mg)==YES) {
> 		    Memc[title] = EOS
> 		    if (DOBIAS(mg) == YES) {
> 		        call sprintf (Memc[procstr], SZ_LINE, ",bias")
> 			call strcat (Memc[procstr], Memc[title], SZ_LINE)
> 		    }
> 		    if (DOZERO(mg) == YES) {
> 		        call sprintf (Memc[procstr], SZ_LINE, ",zero=%s")
> 			    call pargstr (ZERONAME(mg))
> 			call strcat (Memc[procstr], Memc[title], SZ_LINE)
> 		    }
> 		    if (DOFLAT(mg) == YES) {
> 		        call sprintf (Memc[procstr], SZ_LINE, ",flat=%s")
> 			    call pargstr (FLATNAME(mg))
> 			call strcat (Memc[procstr], Memc[title], SZ_LINE)
> 		    }
> 		    call sprintf (Memc[procstr], SZ_LINE, "] %s")
282a297,298
> 		    call strcat (Memc[procstr], Memc[title], SZ_LINE)
> 		    Memc[title] = '['
429c445
< 	call fprintf (fd, "   Amp:%17tIndividual%34tDisplay (zcombine=%s)\n")
---
> 	call fprintf (fd, " Image:%17tIndividual%34tDisplay (zcombine=%s)\n")
466,467c482
< # descriptor file.  If "repeat" mode is enabled, read the graphics descriptor
< # file and reuse the transformations therein.
---
> # descriptor file.
489c504
< pointer maskcolor_map(), yt_pmmap(), zsc_pmsection()
---
> pointer xmaskcolor_map(), yt_pmmap(), zsc_pmsection()
492c507
< errchk	maskcolor_map, yt_pmmap, zsc_pmsection, msc_mzscale
---
> errchk	xmaskcolor_map, yt_pmmap, zsc_pmsection, msc_mzscale
508c523
< 	    W_OCOLORS(wdes) = maskcolor_map (Memc[str])
---
> 	    W_OCOLORS(wdes) = xmaskcolor_map (Memc[str])
514c529
< 	    W_BPCOLORS(wdes) = maskcolor_map (Memc[str])
---
> 	    W_BPCOLORS(wdes) = xmaskcolor_map (Memc[str])
641a657,664
> 	# I don't remember why the changes indicated by the commented code
> 	# above were done.  So the following is a hack for a specific
> 	# case.
> 	if (nint((W_XE(wdpix)-W_XS(wdpix))-(W_XE(wipix)-W_XS(wipix))) == 1)
> 	    W_XE(wdpix) = W_XE(wdpix) - 1
> 	if (nint((W_YE(wdpix)-W_YS(wdpix))-(W_YE(wipix)-W_YS(wipix))) == 1)
> 	    W_YE(wdpix) = W_YE(wdpix) - 1
> 
949a973
> int	color
958c982
< int	imstati(), maskcolor()
---
> int	imstati(), xmaskcolor()
960,961c984,986
< pointer	yigm2s(), zigm2_setup(), zigm2s(), zigm2r()
< errchk	yt_pmmap, imps2s, imps2r, yigm2s, zigm2_setup, zigm2s, zigm2r
---
> pointer	yigm2i(), zigm2_setup(), zigm2s(), zigm2r()
> errchk	yt_pmmap, imps2s, imps2r, yigm2i, zigm2_setup, zigm2s, zigm2r
> errchk	xmaskexprn
1105c1130,1131
< 		    in = yigm2s (si_ovrly, wy - wy1 + 1)
---
> 		    in = yigm2i (si_ovrly, wy - wy1 + 1)
> 		    call xmaskexprn (ocolors, in, nx)
1107,1109c1133,1137
< 			if (Mems[in+i] != 0)
< 			    Mems[out+i] = maskcolor (ocolors,
< 				int(Mems[in+i]))
---
> 			if (Memi[in+i] != 0) {
> 			    color = xmaskcolor (ocolors, Memi[in+i])
> 			    if (color >= 0)
> 				Mems[out+i] = color
> 			}
1113c1141,1142
< 		    in = yigm2s (si_bpovrly, wy - wy1 + 1)
---
> 		    in = yigm2i (si_bpovrly, wy - wy1 + 1)
> 		    call xmaskexprn (ocolors, in, nx)
1115,1117c1144,1148
< 			if (Mems[in+i] != 0)
< 			    Mems[out+i] = maskcolor (bpcolors,
< 				int(Mems[in+i]))
---
> 			if (Memi[in+i] != 0) {
> 			    color = xmaskcolor (ocolors, Memi[in+i])
> 			    if (color >= 0)
> 				Mems[out+i] = color
> 			}
1138c1169,1170
< 		    in = yigm2s (si_ovrly, wy - wy1 + 1)
---
> 		    in = yigm2i (si_ovrly, wy - wy1 + 1)
> 		    call xmaskexprn (ocolors, in, nx)
1140,1142c1172,1176
< 			if (Mems[in+i] != 0)
< 			    Mems[out+i] = maskcolor (ocolors,
< 				 int(Mems[in+i]))
---
> 			if (Memi[in+i] != 0) {
> 			    color = xmaskcolor (ocolors, Memi[in+i])
> 			    if (color >= 0)
> 				Mems[out+i] = color
> 			}
1146c1180,1181
< 		    in = yigm2s (si_bpovrly, wy - wy1 + 1)
---
> 		    in = yigm2i (si_bpovrly, wy - wy1 + 1)
> 		    call xmaskexprn (ocolors, in, nx)
1148,1150c1183,1187
< 			if (Mems[in+i] != 0)
< 			    Mems[out+i] = maskcolor (bpcolors,
< 				int(Mems[in+i]))
---
> 			if (Memi[in+i] != 0) {
> 			    color = xmaskcolor (ocolors, Memi[in+i])
> 			    if (color >= 0)
> 				Mems[out+i] = color
> 			}
1175c1212,1213
< 		    in = yigm2s (si_ovrly, wy - wy1 + 1)
---
> 		    in = yigm2i (si_ovrly, wy - wy1 + 1)
> 		    call xmaskexprn (ocolors, in, nx)
1177,1179c1215,1219
< 			if (Mems[in+i] != 0)
< 			    Memr[out+i] = maskcolor (ocolors,
< 				int(Mems[in+i]))
---
> 			if (Memi[in+i] != 0) {
> 			    color = xmaskcolor (ocolors, Memi[in+i])
> 			    if (color >= 0)
> 				Memr[out+i] = color
> 			}
1183c1223,1224
< 		    in = yigm2s (si_bpovrly, wy - wy1 + 1)
---
> 		    in = yigm2i (si_bpovrly, wy - wy1 + 1)
> 		    call xmaskexprn (ocolors, in, nx)
1185,1187c1226,1230
< 			if (Mems[in+i] != 0)
< 			    Memr[out+i] = maskcolor (bpcolors,
< 				int(Mems[in+i]))
---
> 			if (Memi[in+i] != 0) {
> 			    color = xmaskcolor (ocolors, Memi[in+i])
> 			    if (color >= 0)
> 				Memr[out+i] = color
> 			}
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/src/t_mscrtdisp.x ./src/t_mscrtdisp.x
36c36
< pointer sp, image, image1, title, imtitle, wcs, y1, y2, done
---
> pointer sp, image, image1, title, procstr, imtitle, wcs, y1, y2, done
39c39
< bool    clgetb(), fp_equalr(), streq(), ccdflag()
---
> bool    clgetb(), fp_equalr(), streq(), hdmflag()
40a41
> int	imtlen(), imtgetim()
42c43
< pointer mimap(), immap(), imd_mapframe1(), iw_open()
---
> pointer mimap(), immap(), imd_mapframe1(), iw_open(), imtopenp()
52a54
>         call salloc (procstr, SZ_LINE, TY_CHAR)
57c59,60
<         call clgstr ("instrument",  Memc[image1],  SZ_LINE)
---
>         #call clgstr ("instrument",  Memc[image1],  SZ_LINE)
> 	Memc[image1] = EOS
65c68,74
<         call clgstr ("image", Memc[image], SZ_LINE)
---
> 	# Get image.
> 	im = imtopenp ("image")
> 	if (imtlen (im) != 1)
> 	    call error (1, "Only one image may be displayed")
> 	i = imtgetim (im, Memc[image], SZ_LINE)
> 	call imtclose (im)
> 
189c198
< 			if (!ccdflag (im, "flatcor")) {
---
> 			if (!hdmflag (im, "flatcor")) {
297,307c306,328
< 			if (DOBIAS(mg) == YES && DOFLAT(mg) == YES) {
< 			    call sprintf (Memc[title], SZ_LINE,
< 				"[bias,flat=%s] %s")
< 				call pargstr (FLATNAME(mg))
< 				call pargstr (IM_TITLE(MI_IM(mi,j)))
< 			} else if (DOBIAS(mg) == YES) {
< 			    call sprintf (Memc[title], SZ_LINE, "[bias] %s")
< 				call pargstr (IM_TITLE(MI_IM(mi,j)))
< 			} else if (DOFLAT(mg) == YES) {
< 			    call sprintf (Memc[title], SZ_LINE, "[flat=%s] %s")
< 				call pargstr (FLATNAME(mg))
---
> 			if (DOBIAS(mg)==YES || DOZERO(mg)==YES ||
> 			    DOFLAT(mg)==YES) {
> 			    Memc[title] = EOS
> 			    if (DOBIAS(mg) == YES) {
> 				call sprintf (Memc[procstr], SZ_LINE, ",bias")
> 				call strcat (Memc[procstr], Memc[title],
> 				    SZ_LINE)
> 			    }
> 			    if (DOZERO(mg) == YES) {
> 				call sprintf (Memc[procstr], SZ_LINE,
> 				    ",zero=%s")
> 				    call pargstr (ZERONAME(mg))
> 				call strcat (Memc[procstr], Memc[title],
> 				    SZ_LINE)
> 			    }
> 			    if (DOFLAT(mg) == YES) {
> 				call sprintf (Memc[procstr], SZ_LINE,
> 				    ",flat=%s")
> 				    call pargstr (FLATNAME(mg))
> 				call strcat (Memc[procstr], Memc[title],
> 				    SZ_LINE)
> 			    }
> 			    call sprintf (Memc[procstr], SZ_LINE, "] %s")
308a330,331
> 			    call strcat (Memc[procstr], Memc[title], SZ_LINE)
> 			    Memc[title] = '['
diff -r /u2/valdes/iraf/mscred/iraf214/mscred4.9/mscred/src/mscdisplay/x_mscdisplay.x ./x_mscdisplay.x
1c1,2
< task	mscdisplay 	= t_mscdisplay,
---
> task	acedisplay	= t_mscdisplay,
> 	mscdisplay 	= t_mscdisplay,
